<!DOCTYPE html>
<html lang="pl">
<head>
  <!-- Google tag (gtag.js) i Hotjar są inicjowane po akceptacji cookies w assets/cookies.js -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grunteo - Oferty działek na sprzedaż</title>
  <meta name="description" content="Przeglądaj aktualne oferty działek budowlanych, rolnych i inwestycyjnych z całej Polski na platformie Grunteo." />
  <meta name="keywords" content="działki,oferty,grunty,sprzedaż,wynajem,Polska,nieruchomości,inwestycja,budowlane,rolne" />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://grunteo.pl/oferty" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <link rel="icon" type="image/svg+xml" href="https://grunteo.pl/brand/logo-mark.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://grunteo.pl/brand/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://grunteo.pl/brand/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://grunteo.pl/brand/favicon-16x16.png" />
  <link rel="manifest" href="https://grunteo.pl/brand/site.webmanifest" />
  <link rel="mask-icon" href="https://grunteo.pl/brand/safari-pinned-tab.svg" color="#0c0d11" />
  <link rel="shortcut icon" href="https://grunteo.pl/brand/favicon.ico" />
  <meta name="apple-mobile-web-app-title" content="Grunteo" />
  <meta name="application-name" content="Grunteo" />
  <meta name="msapplication-TileColor" content="#0c0d11" />
  <meta name="msapplication-config" content="https://grunteo.pl/brand/browserconfig.xml" />
  <meta name="theme-color" content="#0c0d11" />
  <meta property="og:image" content="https://grunteo.pl/brand/og-image.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:alt" content="Logo Grunteo" />
  <meta property="og:title" content="Grunteo - Oferty działek na sprzedaż" />
  <meta property="og:description" content="Odkryj najnowsze ogłoszenia działek z całego kraju i znajdź grunt dopasowany do Twoich potrzeb." />
  <meta property="og:url" content="https://grunteo.pl/oferty" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://grunteo.pl/brand/og-image.png" />
  <meta name="twitter:title" content="Grunteo - Oferty działek na sprzedaż" />
  <meta name="twitter:description" content="Przeglądaj aktualne oferty działek w całej Polsce i filtruj ogłoszenia według swoich kryteriów." />
  <link rel="stylesheet" href="assets/main.css" />
  <link rel="stylesheet" href="assets/header.css" />
  <link rel="stylesheet" href="assets/oferty.css" />
  <script src="assets/offers-cache-config.js"></script>
  <!-- Google tag (gtag.js) -->
  <script type="text/plain" data-cookie-consent="analytics" data-cookie-src="https://www.googletagmanager.com/gtag/js?id=G-VH07LRZ8GK" data-cookie-async="true"></script>
  <script type="text/plain" data-cookie-consent="analytics">
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VH07LRZ8GK', { 'anonymize_ip': true });
  </script>

  <!-- Hotjar Tracking Code for grunteo.pl -->
  <script type="text/plain" data-cookie-consent="analytics">
    (function(h,o,t,j,a,r){
      h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments);};
      h._hjSettings={hjid:6523622,hjsv:6};
      a=o.getElementsByTagName('head')[0];
      r=o.createElement('script');r.async=1;
      r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
      a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  </script>

</head>
<body>
  <div class="top-navbar">
    <div class="contact-info">
      <i class="fas fa-clock"></i> Poniedziałek - Piątek 9:00 - 18:00
      <span><i class="fas fa-phone"></i> +48 505 849 404</span>
    </div>

    <div class="auth-buttons" id="authButtons">
      <button class="btn btn-outline-primary btn-sm" id="loginBtn">
        <i class="fas fa-sign-in-alt"></i> Zaloguj się
      </button>
      <button class="btn btn-primary btn-sm" id="registerBtn">
        <i class="fas fa-user-plus"></i> Zarejestruj się
      </button>
    </div>

    <div class="user-menu" id="userMenu" style="display:none;">
      <button class="btn btn-outline-primary btn-sm" id="accountBtn">
        <i class="fas fa-user"></i> Moje konto
      </button>

      <button class="btn btn-secondary btn-sm" id="logoutBtn">
        <i class="fas fa-sign-out-alt"></i> Wyloguj
      </button>
    </div>
  </div>

  <header>
    <a href="index.html" class="logo">
      <img src="https://grunteo.pl/brand/logo-horizontal-dark.svg" alt="Logo serwisu">
    </a>

    <nav class="desktop-nav">
      <a href="index.html" class="nav-link">Strona główna</a>
      <a href="oferty.html" class="nav-link active">Oferty</a>
      <a href="dodaj.html" class="nav-link">Dodaj</a>
      <a href="Kontakt.html" class="nav-link">Kontakt</a>
    </nav>

    <a href="dodaj.html" class="desktop-add-offer">
      <i class="fas fa-plus"></i> Dodaj ofertę
    </a>
    <a href="dodaj.html" class="mobile-add-offer">
      <i class="fas fa-plus"></i> Dodaj ofertę
    </a>

    <button class="mobile-menu-btn" aria-label="Otwórz menu">
      <i class="fas fa-bars"></i>
    </button>

    <nav class="nav-menu">
      <a href="index.html" class="nav-link">Strona główna</a>
      <a href="oferty.html" class="nav-link active">Oferty</a>
      <a href="dodaj.html" class="nav-link">Dodaj</a>
      <a href="Kontakt.html" class="nav-link">Kontakt</a>
      <a href="index.html#userMenu" class="nav-link">Moje konto</a>

      <!-- Miejsce na elementy auth w menu mobilnym -->
      <div class="mobile-auth" id="mobileAuth" style="display:none;"></div>
    </nav>
  </header>


<!-- Toasts -->
<div class="toast-container" id="toastContainer" aria-live="polite" aria-atomic="true"></div>
<!-- Confirm Modal -->
<div class="confirm-modal" id="confirmModal" role="dialog" aria-modal="true">
  <div class="confirm-box">
    <h3 class="confirm-title">Potwierdzenie</h3>
    <p class="confirm-message"></p>
    <div class="confirm-actions">
      <button class="confirm-btn confirm-cancel">Anuluj</button>
      <button class="confirm-btn confirm-yes">Usuń</button>
    </div>
  </div>
</div>
<script>
/* ===== UI: TOAST (vanilla) =====
   showToast('Oferta „...” została usunięta.', 'success')
   type: 'info' | 'success' | 'warning' | 'error'
*/
function showToast(message, type = 'info') {
  const container = document.getElementById('toastContainer');
  if (!container) return;

  const wrap = document.createElement('div');
  wrap.className = `toast-lite toast-${type}`;
  wrap.setAttribute('role', 'status');
  wrap.setAttribute('aria-live', 'polite');

  // dobierz ikonę
  const icon = {
    success: '✓',
    info: 'ℹ',
    warning: '!',
    error: '✕'
  }[type] || 'ℹ';

  wrap.innerHTML = `
    <div class="toast-icon" aria-hidden="true">${icon}</div>
    <div class="toast-msg">${message}</div>
    <button class="toast-close" aria-label="Zamknij">&times;</button>
  `;

  // zamykanie
  const close = () => {
    wrap.classList.remove('show');
    setTimeout(() => wrap.remove(), 160);
  };
  wrap.querySelector('.toast-close').addEventListener('click', close);

  // dodaj + animacja wejścia
  container.appendChild(wrap);
  requestAnimationFrame(() => wrap.classList.add('show'));

  // auto-hide po 4s
  const t = setTimeout(close, 4000);
  // jeśli użytkownik najedzie, nie chowaj
  wrap.addEventListener('mouseenter', () => clearTimeout(t), { once: true });
}
</script>

<!-- Confirm Modal Script -->
<script>
function showConfirmModal(message) {
  return new Promise(resolve => {
    const modal = document.getElementById('confirmModal');
    if (!modal) return resolve(false);

    modal.querySelector('.confirm-message').textContent = message;
    modal.classList.add('show');

    const yesBtn = modal.querySelector('.confirm-yes');
    const cancelBtn = modal.querySelector('.confirm-cancel');

    const cleanup = () => {
      modal.classList.remove('show');
      yesBtn.removeEventListener('click', onYes);
      cancelBtn.removeEventListener('click', onCancel);
      modal.removeEventListener('click', onOutside);
    };

    const onYes = () => { cleanup(); resolve(true); };
    const onCancel = () => { cleanup(); resolve(false); };
    const onOutside = (e) => { if (e.target === modal) { cleanup(); resolve(false); } };

    yesBtn.addEventListener('click', onYes, { once: true });
    cancelBtn.addEventListener('click', onCancel, { once: true });
    modal.addEventListener('click', onOutside, { once: true });
  });
}
window.showConfirmModal = showConfirmModal;
</script>


  <!-- ===== GŁÓWNY UKŁAD Z MAPĄ I ZAWARTOŚCIĄ ===== -->
  <div class="main-layout">
    <!-- Lewa strona - statyczna mapa -->
    <div class="map-container">
      <div id="map"></div>
      <div id="map-controls"></div>
    </div>

    <!-- Prawa strona - przewijana zawartość -->
    <div class="content-container">
      <div class="sidebar-stack">
        <div class="voronoi-panel" id="voronoiPanel">
          <div class="voronoi-panel__header">
            <h3 class="filters-title voronoi-panel__title" id="voronoiPanelTitle">Wycena nieruchomości (beta)</h3>
            <div class="voronoi-toggle" role="group" aria-labelledby="voronoiPanelTitle">
              <div class="voronoi-toggle__controls">
                <input
                  type="checkbox"
                  id="toggleVoronoiLayer"
                  class="voronoi-toggle__input"
                  aria-label="Przełącz warstwę wyceny nieruchomości"
                />
                <button
                  type="button"
                  class="voronoi-toggle__option"
                  data-voronoi-toggle="on"
                  aria-pressed="false"
                  aria-label="Włącz warstwę"
                >
                  Wł.
                </button>
                <button
                  type="button"
                  class="voronoi-toggle__option"
                  data-voronoi-toggle="off"
                  aria-pressed="false"
                  aria-label="Wyłącz warstwę"
                >
                  Wył.
                </button>
              </div>
            </div>
          </div>
          <div class="voronoi-legend" aria-live="polite">
            <div class="voronoi-legend__item">
              <span class="voronoi-legend__swatch voronoi-legend__swatch--selected" aria-hidden="true"></span>
              <span class="voronoi-legend__label">Zaznaczona wycena</span>
            </div>
            <div class="voronoi-legend__item">
              <span class="voronoi-legend__swatch voronoi-legend__swatch--source" aria-hidden="true"></span>
              <span class="voronoi-legend__label">Źródło wyceny</span>
            </div>
            <div class="voronoi-legend__item">
              <span class="voronoi-legend__swatch voronoi-legend__swatch--filtered" aria-hidden="true">&times;</span>
              <span class="voronoi-legend__label">Dane odfiltrowane</span>
            </div>
            <div class="voronoi-legend__item">
              <span class="voronoi-legend__swatch voronoi-legend__swatch--archival" aria-hidden="true">&times;</span>
              <span class="voronoi-legend__label">Dane archiwalne</span>
            </div>
          </div>
          <div
            class="voronoi-inspector"
            id="voronoiInspector"
            aria-hidden="true"
            hidden
          >
            <div class="voronoi-inspector__summary" id="voronoiInspectorSummary" hidden>
              <div class="voronoi-inspector__summary-header">
                <span class="voronoi-inspector__summary-title">Podsumowanie</span>
                <span class="voronoi-inspector__summary-badge" id="voronoiInspectorSummaryBadge" hidden>szac.</span>
              </div>
              <div class="voronoi-inspector__summary-grid">
                <div class="voronoi-inspector__summary-item">
                  <span class="voronoi-inspector__summary-label">Średnia cena m²</span>
                  <span class="voronoi-inspector__summary-value" id="voronoiInspectorAvgValue">—</span>
                </div>
                <div class="voronoi-inspector__summary-item">
                  <span class="voronoi-inspector__summary-label">Szacowana wartość działki</span>
                  <span class="voronoi-inspector__summary-value" id="voronoiInspectorEstimateValue">—</span>
                </div>
              </div>
            </div>
            <p
              class="voronoi-inspector__empty"
              id="voronoiInspectorEmpty"
              data-default-message="Kliknij poligon, aby zobaczyć procenty tagów."
            >
              Kliknij poligon, aby zobaczyć procenty tagów.
            </p>
            <ul class="voronoi-inspector__list" id="voronoiInspectorList"></ul>
          </div>
        </div>

        <!-- Panel filtrów ofert -->
        <div class="filters-panel" id="filtersPanel">
          <h3 class="filters-title">Filtruj działki</h3>
          <div class="filters-row sort-row">
            <span class="filters-label">Sortuj:</span>
            <div class="sort-buttons">
              <button type="button" class="sort-chip" data-sort-key="price" aria-pressed="false">
                Cena
              </button>
              <button type="button" class="sort-chip" data-sort-key="area" aria-pressed="false">
                Powierzchnia
              </button>
            </div>
          </div>
          <div class="filters-row tags-row">
            <span class="filters-label">Tagi:</span>
            <div class="tags-area">
              <div class="tags-wrapper" id="tagFiltersList" data-expanded="false">
                <span class="tag-placeholder">Ładuję tagi…</span>
              </div>
              <button type="button" class="toggle-tags-btn" id="toggleTagsBtn" aria-expanded="false" aria-controls="tagFiltersList" hidden>
                Pokaż wszystkie tagi
              </button>
            </div>
          </div>
        </div>
      </div>
      <!-- Panel z ofertami publicznymi -->
      <div class="offers-section">
        <div class="section-title">
          <h2>Oferty działek</h2>
        </div>
        <div class="offers-list" id="offersList"></div>
      </div>
      
      <!-- Panel z Twoimi ofertami -->
      <div class="offers-section">
        <div class="section-title">
          <h2>Moje Oferty</h2>
        </div>
        <div id="userDashboard">
          <div class="offers-grid" id="userOffers"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal" id="loginModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Zaloguj się</h3>
        <button class="modal-close" aria-label="Zamknij">&times;</button>
      </div>
      <form id="loginForm">
        <div class="form-group">
          <label for="loginEmail">Email</label>
          <input type="email" id="loginEmail" required>
        </div>
        <div class="form-group">
          <label for="loginPassword">Hasło</label>
          <input type="password" id="loginPassword" required>
        </div>
        <button type="submit" class="btn btn-primary" style="width:100%;">Zaloguj się</button>
      </form>

      <div class="social-login">
        <button type="button" class="btn btn-google" id="googleLoginBtnLogin">
          <i class="fab fa-google"></i> Kontynuuj z Google
        </button>
      </div>

      <div class="form-footer">
        <p>Nie masz konta? <a href="#" id="switchToRegister">Zarejestruj się</a></p>
      </div>
    </div>
  </div>

  <!-- Register Modal -->
  <div class="modal" id="registerModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Utwórz konto</h3>
        <button class="modal-close" aria-label="Zamknij">&times;</button>
      </div>
      <form id="registerForm">
        <div class="form-group">
          <label for="registerName">Imię i nazwisko</label>
          <input type="text" id="registerName" required>
        </div>
        <div class="form-group">
          <label for="registerEmail">Email</label>
          <input type="email" id="registerEmail" required>
        </div>
        <div class="form-group">
          <label for="registerPassword">Hasło</label>
          <input type="password" id="registerPassword" required>
        </div>
        <div class="form-group">
          <label for="registerConfirmPassword">Potwierdź hasło</label>
          <input type="password" id="registerConfirmPassword" required>
        </div>
        <button type="submit" class="btn btn-primary" style="width:100%;">Zarejestruj się</button>
      </form>

      <div class="social-login mt-3 text-center">
        <button type="button" class="btn btn-google w-100 mb-2" id="googleLoginBtn">
          <i class="fab fa-google"></i> Kontynuuj z Google
        </button>
      </div>

      <div class="form-footer">
        <p>Masz już konto? <a href="#" id="switchToLogin">Zaloguj się</a></p>
      </div>
    </div>
  </div>

  <!-- Modal edycji -->
  <div class="modal" id="editModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Edytuj ofertę</h3>
        <button class="modal-close">&times;</button>
      </div>
      <form id="editForm">
        <input type="hidden" id="editOfferId">
        <input type="hidden" id="editPlotIndex">
        
        <div class="form-group">
          <label for="editPlotId">Identyfikator działki</label>
          <input type="text" id="editPlotId" required>
        </div>
        
        <div class="form-group">
          <label for="editPrice">Cena całkowita (zł)</label>
          <input type="number" id="editPrice" required>
        </div>
        
        <div class="form-group">
          <label for="editPhone">Telefon kontaktowy</label>
          <input type="tel" id="editPhone" required>
        </div>
        
        <div class="form-group">
          <label for="editCity">Miejscowość</label>
          <input type="text" id="editCity" required>
        </div>
        
        <button type="submit" class="btn btn-primary" style="width: 100%;">Zaktualizuj ofertę</button>
      </form>
  </div>
</div>
  <!-- Firebase -->
  <script type="module">
    import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      getDocs,
      query,
      where,
      orderBy,
      limit,
      startAfter,
      Timestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBdhMIiqetOfDGP85ERxtgwn3AXR50pBcE",
      authDomain: "base-468e0.firebaseapp.com",
      projectId: "base-468e0",
      storageBucket: "base-468e0.firebasestorage.app",
      messagingSenderId: "829161895559",
      appId: "1:829161895559:web:d832541aac05b35847ea22"
    };

    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    const db = getFirestore(app);

    window.firebaseApp = app;

    window.db = db;
    window.collection = collection;
    window.getDocs = getDocs;
    window.query = query;
    window.where = where;
    window.orderBy = orderBy;
    window.limit = limit;
    window.startAfter = startAfter;
    window.Timestamp = Timestamp;
  </script>











<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.2/dist/d3-delaunay.min.js"></script>

<script>
  let map;
  let markers = [];
  let markerCluster;
  let allOffers = [];
  let availableTags = [];
  let tagMetrics = new Map();
  const filterState = {
    sortKey: null,
    sortDir: 'asc',
    selectedTags: new Set()
  };
  let tagsExpanded = false;
  const TAG_PREVIEW_COUNT = 5;
  let randomPreviewTags = [];
  let randomPreviewSignature = '';
  let currentVisibleOffers = [];
  let voronoiSupplementaryOffers = [];
  let currentVoronoiOffers = [];
  let currentVoronoiSupplementary = [];
  let voronoiHiddenOffersInBounds = [];
  let voronoiSupplementaryOffersInBounds = [];
  const voronoiIndicatorState = {
    hidden: [],
    supplementary: []
  };
  const voronoiLayerState = {
    enabled: false,
    polygons: [],
    connectors: [],
    labels: [],
    tagWeights: new Map(),
    maxTagValue: 1,
    labelLayout: {
      overlay: null,
      boxes: [],
      projectionPending: false
    },
    cachedDataset: null,
    cacheSignature: null,
    frozenLayout: null,
    lastNonFrozenSource: {
      offers: [],
      signature: null,
      extent: null
    },
    connectorIndexMap: new Map(),
    resolvedValues: [],
    datasetSnapshot: [],
    cells: [],
    adjacencyList: [],
    currentExtent: null,
    selectionLock: null,
    highlight: {
      baseIndex: null,
      selectedOfferKey: null,
      selectedIndexHint: null,
      polygons: new Set(),
      connectors: new Set(),
      hiddenPolygons: new Map(),
      ignoreNextMapClear: false
    }
  };

  const MAP_LAYER_BASE_URLS = {
    lokalizacja: 'https://grunteo.s3.eu-west-3.amazonaws.com/Orto_Esri%2BGrunty/MARGE_Orto_Esri%2BGrunty',
    media: 'https://grunteo.s3.eu-west-3.amazonaws.com/Cyclosm_Esri%2BGESUT/MARGE_Cyclosm_Esri%2BGESUT',
    teren: 'https://grunteo.s3.eu-west-3.amazonaws.com/GRID%2BGrunty/MARGE_GRID%2BGrunty',
    mpzp: 'https://grunteo.s3.eu-west-3.amazonaws.com/MPZP%2BGrunty/MARGE_MPZP%2BGrunty',
    mpzpskan: 'https://grunteo.s3.eu-west-3.amazonaws.com/MPZP_rastrowe%2BGrunty/MARGE_MPZP_rastrowe%2BGrunty',
    studium: 'https://grunteo.s3.eu-west-3.amazonaws.com/Studium%2BGrunty/MARGE_Studium%2BGrunty',
    uzytkigruntowe: 'https://grunteo.s3.eu-west-3.amazonaws.com/Uzytki%2BGrunty/MARGE_Uzytki%2BGrunty'
  };

  const PREVIEW_PRIORITY_KEYS = ['lokalizacja', 'teren', 'media', 'mpzp', 'mpzpskan', 'studium', 'uzytkigruntowe'];

  const isUrlLike = (value) => typeof value === 'string' && /^(https?:)?\/\//i.test(value.trim());

  function resolveImageUrl(value) {
    if (!value) return '';
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (!trimmed) return '';
      if (isUrlLike(trimmed) || trimmed.startsWith('data:') || trimmed.startsWith('/') || trimmed.startsWith('./') || trimmed.startsWith('../')) {
        return trimmed;
      }
      return '';
    }
    if (typeof value === 'object') {
      const candidate = value.url ?? value.href ?? value.src ?? value.value ?? value.link;
      if (typeof candidate === 'string') {
        return resolveImageUrl(candidate);
      }
    }
    return '';
  }

  function normalizeLayerKey(key) {
    return String(key || '')
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '');
  }

  function matchLayerKey(rawKey) {
    const normalized = normalizeLayerKey(rawKey);
    if (!normalized) return '';
    const aliasMap = {
      lokalizacja: ['lokalizacja', 'location', 'localization', 'orto', 'orthophoto', 'aerial'],
      media: ['media', 'uzbrojenie', 'utilities', 'gesut', 'cyclosm'],
      teren: ['teren', 'terrain', 'grid', 'ground', 'siatka'],
      mpzp: ['mpzp', 'plan', 'zoning', 'miejscowyplan'],
      mpzpskan: ['mpzpskan', 'mpzpraster', 'mpzprastrowe', 'mpzpscan', 'planraster', 'planrasterowy', 'planzdjecie', 'skanmpzp', 'scanplanu'],
      studium: ['studium', 'study', 'uwarunkowania', 'kierunki'],
      uzytkigruntowe: ['uzytkigruntowe', 'uzytki', 'uzytkirolne', 'landuse', 'landusage', 'pokryciegruntu']
    };

    for (const [target, aliases] of Object.entries(aliasMap)) {
      if (normalized === target) return target;
      for (const alias of aliases) {
        if (normalized === alias || normalized.includes(alias) || alias.includes(normalized)) {
          return target;
        }
      }
    }
    return '';
  }

  function extractLayerImages(source) {
    const result = {};
    if (!source) return result;
    if (Array.isArray(source)) {
      source.forEach(item => Object.assign(result, extractLayerImages(item)));
      return result;
    }
    if (typeof source !== 'object') return result;

    const candidateKey = source.key ?? source.type ?? source.layer ?? source.name ?? source.label;
    const candidateUrl = source.url ?? source.href ?? source.src ?? source.value ?? source.link;
    const matchedKey = matchLayerKey(candidateKey);
    const resolvedUrl = resolveImageUrl(candidateUrl);
    if (matchedKey && resolvedUrl) {
      result[matchedKey] = resolvedUrl;
    }

    Object.entries(source).forEach(([key, value]) => {
      const layerKey = matchLayerKey(key);
      if (!layerKey) return;
      const url = resolveImageUrl(value);
      if (url) {
        result[layerKey] = url;
      }
    });

    return result;
  }

  function collectMapImages(plot = {}, offer = {}, plotIndex = 0, fallbackId = '') {
    const sources = [
      plot.mapImages,
      plot.mapTiles,
      plot.mapLayers,
      plot.planImages,
      plot.planTiles,
      plot.mapPreviews,
      plot.mapGallery,
      offer.mapImages,
      offer.mapTiles,
      offer.mapLayers,
      offer.planImages,
      offer.planTiles,
      offer.mapPreviews,
      offer.mapGallery
    ];

    const result = {};
    sources.forEach(source => Object.assign(result, extractLayerImages(source)));

    const directFields = {
      lokalizacja: [
        plot.mapLokalizacja,
        plot.lokalizacjaMap,
        plot.mapLocation,
        plot.locationMap,
        offer.mapLokalizacja,
        offer.lokalizacjaMap,
        offer.mapLocation,
        offer.locationMap
      ],
      media: [
        plot.mapMedia,
        plot.mediaMap,
        plot.mapUzbrojenie,
        plot.mapGesut,
        offer.mapMedia,
        offer.mediaMap,
        offer.mapUzbrojenie,
        offer.mapGesut
      ],
      teren: [
        plot.mapTeren,
        plot.terrainMap,
        plot.mapGrid,
        plot.gridMap,
        offer.mapTeren,
        offer.terrainMap,
        offer.mapGrid,
        offer.gridMap
      ],
      mpzp: [
        plot.mapMpzp,
        plot.mapMPZP,
        plot.mpzpMap,
        plot.planMap,
        offer.mapMpzp,
        offer.mapMPZP,
        offer.mpzpMap,
        offer.planMap
      ],
      mpzpskan: [
        plot.mapMpzpSkan,
        plot.mapMpzpScan,
        plot.mapMpzpRaster,
        plot.mapMpzpRastrowe,
        plot.mapMPZPSkan,
        plot.mapMPZPScan,
        plot.mapMPZPRaster,
        plot.mpzpSkan,
        plot.mpzpScan,
        plot.mpzpRaster,
        plot.planRaster,
        plot.planScan,
        plot.planSkan,
        offer.mapMpzpSkan,
        offer.mapMpzpScan,
        offer.mapMpzpRaster,
        offer.mapMpzpRastrowe,
        offer.mapMPZPSkan,
        offer.mapMPZPScan,
        offer.mapMPZPRaster,
        offer.mpzpSkan,
        offer.mpzpScan,
        offer.mpzpRaster,
        offer.planRaster,
        offer.planScan,
        offer.planSkan
      ],
      studium: [
        plot.mapStudium,
        plot.studiumMap,
        offer.mapStudium,
        offer.studiumMap
      ],
      uzytkigruntowe: [
        plot.mapUzytki,
        plot.mapUzytkiGruntowe,
        plot.mapUzytkiGruntu,
        plot.mapUzytkiRolne,
        plot.uzytkiMap,
        plot.uzytkiGruntoweMap,
        plot.mapLandUse,
        plot.landUseMap,
        plot.landuseMap,
        plot.mapLandcover,
        offer.mapUzytki,
        offer.mapUzytkiGruntowe,
        offer.mapUzytkiGruntu,
        offer.mapUzytkiRolne,
        offer.uzytkiMap,
        offer.uzytkiGruntoweMap,
        offer.mapLandUse,
        offer.landUseMap,
        offer.landuseMap,
        offer.mapLandcover
      ]
    };

    Object.entries(directFields).forEach(([key, values]) => {
      if (result[key]) return;
      for (const value of values) {
        const url = resolveImageUrl(value);
        if (url) {
          result[key] = url;
          break;
        }
      }
    });

    const candidateIds = [
      typeof fallbackId === 'string' ? fallbackId.trim() : fallbackId,
      plot.mapImageId,
      plot.mapId,
      plot.imageId,
      plot.imagesId,
      plot.plotId,
      plot.Id,
      plot.id,
      offer.mapImageId,
      offer.mapId,
      offer.plotId,
      offer.Id,
      offer.id
    ];

    const trimmedId = candidateIds
      .map(value => {
        if (value === undefined || value === null) return '';
        const text = typeof value === 'string' ? value : String(value);
        return text.trim();
      })
      .find(value => value && /^[A-Za-z0-9_-]+$/.test(value)) || '';

    const indexNumber = Number.isFinite(plotIndex) && plotIndex >= 0 ? plotIndex : 0;
    const indexSuffix = `_${String(indexNumber).padStart(3, '0')}`;

    if (trimmedId) {
      const expectedSuffix = `_${trimmedId}${indexSuffix}.png`;
      Object.entries(MAP_LAYER_BASE_URLS).forEach(([key, baseUrl]) => {
        const expectedUrl = `${baseUrl}${expectedSuffix}`;
        const currentUrl = typeof result[key] === 'string' ? result[key].trim() : '';
        if (!currentUrl) {
          result[key] = expectedUrl;
          return;
        }
        const normalizedCurrent = currentUrl.split('?')[0];
        if (!normalizedCurrent.endsWith(expectedSuffix)) {
          result[key] = expectedUrl;
        }
      });
    }

    return result;
  }

  function getPlotPreviewImage(plot, offer, plotIndex, fallbackId) {
    const images = collectMapImages(plot, offer, plotIndex, fallbackId);
    for (const key of PREVIEW_PRIORITY_KEYS) {
      const url = images[key];
      if (url) return url;
    }

    const miscCandidates = [
      plot?.previewImage,
      plot?.previewUrl,
      plot?.thumbnail,
      plot?.image,
      plot?.imageUrl,
      offer?.previewImage,
      offer?.previewUrl,
      offer?.thumbnail,
      offer?.image,
      offer?.imageUrl
    ];

    for (const candidate of miscCandidates) {
      const url = resolveImageUrl(candidate);
      if (url) return url;
    }

    const genericSources = [plot?.mapImage, plot?.mapPreview, offer?.mapImage, offer?.mapPreview];
    for (const source of genericSources) {
      if (!source) continue;
      if (typeof source === 'string') {
        const url = resolveImageUrl(source);
        if (url) return url;
      } else if (typeof source === 'object') {
        const extracted = extractLayerImages(source);
        for (const key of PREVIEW_PRIORITY_KEYS) {
          const url = extracted[key];
          if (url) return url;
        }
        const values = Object.values(source)
          .map(resolveImageUrl)
          .find(Boolean);
        if (values) return values;
      }
    }

    return '';
  }

  const VORONOI_LABEL_SIZE = {
    width: 160,
    height: 64
  };

  function getVoronoiPolygonStyle(mode = 'default') {
    if (mode === 'baseHighlight') {
      return {
        strokeColor: '#15803D',
        strokeOpacity: 0.95,
        strokeWeight: 2.4,
        fillColor: '#DCFCE7',
        fillOpacity: 0.55
      };
    }
    if (mode === 'sourceHighlight') {
      return {
        strokeColor: '#2563EB',
        strokeOpacity: 0.92,
        strokeWeight: 2,
        fillColor: '#A5C8FF',
        fillOpacity: 0.48
      };
    }
    return {
      strokeColor: '#1D4ED8',
      strokeOpacity: 0.72,
      strokeWeight: 1.2,
      fillColor: '#93C5FD',
      fillOpacity: 0.26
    };
  }

  function applyVoronoiPolygonStyle(polygon, mode = 'default') {
    if (!polygon || typeof polygon.setOptions !== 'function') {
      return;
    }
    polygon.setOptions(getVoronoiPolygonStyle(mode));
  }

  function getVoronoiPolygonBaseMode(polygon) {
    if (!polygon) {
      return 'default';
    }
    if (typeof polygon.__voronoiBaseMode === 'string' && polygon.__voronoiBaseMode) {
      return polygon.__voronoiBaseMode;
    }
    return polygon.__voronoiIsAssigned ? 'baseHighlight' : 'default';
  }

  function applyVoronoiBaseStyle(polygon) {
    const baseMode = getVoronoiPolygonBaseMode(polygon);
    applyVoronoiPolygonStyle(polygon, baseMode);
  }

  function buildVoronoiConnectorStyle(mode = 'default') {
    const presets = mode === 'highlight'
      ? { strokeOpacity: 0.95, strokeWeight: 2, scale: 3, repeat: '10px', zIndex: 41 }
      : { strokeOpacity: 0.65, strokeWeight: 1.1, scale: 2, repeat: '12px', zIndex: 38 };

    return {
      strokeColor: '#DC2626',
      strokeOpacity: presets.strokeOpacity,
      strokeWeight: presets.strokeWeight,
      geodesic: true,
      icons: [{
        icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: presets.scale },
        offset: '0',
        repeat: presets.repeat
      }],
      zIndex: presets.zIndex
    };
  }

  function applyVoronoiConnectorStyle(connector, mode = 'default') {
    if (!connector || typeof connector.setOptions !== 'function') {
      return;
    }
    connector.setOptions(buildVoronoiConnectorStyle(mode));
  }

  function getVoronoiLabelMap(label) {
    if (!label) return null;
    if (typeof label.getMap === 'function') {
      try {
        return label.getMap();
      } catch (_) {
        return null;
      }
    }
    if ('map' in label) {
      return label.map || null;
    }
    return null;
  }

  function setVoronoiLabelMap(label, targetMap) {
    if (!label) return;
    if (typeof label.setMap === 'function') {
      label.setMap(targetMap || null);
    } else if ('map' in label) {
      label.map = targetMap || null;
    }
  }

  function setOverlayMap(overlay, targetMap) {
    if (!overlay) return;
    if (typeof overlay.setMap === 'function') {
      overlay.setMap(targetMap || null);
    } else if ('map' in overlay) {
      overlay.map = targetMap || null;
    }
  }

  function createVoronoiIndicatorMarker(position, type) {
    if (!position) return null;
    const isHidden = type === 'hidden';
    const className = isHidden
      ? 'voronoi-indicator voronoi-indicator--hidden'
      : 'voronoi-indicator voronoi-indicator--supplementary';
    const fallbackColor = isHidden ? '#2563EB' : '#DC2626';

    try {
      const advancedMarkerCtor = (typeof google !== 'undefined' && google && google.maps && google.maps.marker && google.maps.marker.AdvancedMarkerElement)
        ? google.maps.marker.AdvancedMarkerElement
        : null;
      if (advancedMarkerCtor) {
        const node = document.createElement('div');
        node.className = className;
        node.textContent = '×';
        return new advancedMarkerCtor({
          position,
          map: null,
          content: node,
          zIndex: 160
        });
      }
    } catch (error) {
      console.warn('Nie udało się utworzyć wskaźnika Voronoi w trybie AdvancedMarkerElement.', error);
    }

    return new google.maps.Marker({
      position,
      map: null,
      icon: { path: google.maps.SymbolPath.CIRCLE, scale: 0.01, strokeWeight: 0 },
      label: {
        text: '×',
        color: fallbackColor,
        fontSize: '14px',
        fontWeight: '700'
      },
      zIndex: 160
    });
  }

  function clearVoronoiIndicators(type = null) {
    const groups = [];
    if (!type || type === 'hidden') {
      groups.push(voronoiIndicatorState.hidden);
    }
    if (!type || type === 'supplementary') {
      groups.push(voronoiIndicatorState.supplementary);
    }
    groups.forEach((collection) => {
      collection.forEach(marker => setOverlayMap(marker, null));
      collection.length = 0;
    });
  }

  function rebuildVoronoiIndicatorMarkers(type, offers) {
    const targetCollection = type === 'hidden'
      ? voronoiIndicatorState.hidden
      : voronoiIndicatorState.supplementary;

    targetCollection.forEach(marker => setOverlayMap(marker, null));
    targetCollection.length = 0;

    if (!map || !Array.isArray(offers) || !offers.length) {
      return;
    }

    offers.forEach(offer => {
      const position = getMarkerPositionForOffer(offer);
      if (!position) return;
      const marker = createVoronoiIndicatorMarker(position, type);
      if (!marker) return;
      setOverlayMap(marker, map);
      targetCollection.push(marker);
    });
  }

  function refreshVoronoiIndicators() {
    if (!map || !voronoiLayerState.enabled) {
      clearVoronoiIndicators();
      return;
    }

    const filterActive = filterState.selectedTags.size > 0;
    const hiddenOffers = filterActive ? voronoiHiddenOffersInBounds : [];

    rebuildVoronoiIndicatorMarkers('hidden', hiddenOffers);
    rebuildVoronoiIndicatorMarkers('supplementary', voronoiSupplementaryOffersInBounds);
  }

  function hasVoronoiValuation(entry) {
    if (!entry) return false;
    const price = Number(entry.price);
    const pricePerSqm = Number(entry.pricePerSqm);
    const hasPrice = (Number.isFinite(price) && price > 0) || (Number.isFinite(pricePerSqm) && pricePerSqm > 0);
    if (hasPrice) {
      return true;
    }
    if (entry.hasPrice) {
      return hasPrice;
    }
    if (Array.isArray(entry.fallbackSources) && entry.fallbackSources.length) {
      return hasPrice;
    }
    return false;
  }

  function shouldDisplayVoronoiPolygon(index) {
    const values = Array.isArray(voronoiLayerState.resolvedValues)
      ? voronoiLayerState.resolvedValues
      : [];
    const entry = values[index];
    return hasVoronoiValuation(entry);
  }

  function applyVoronoiBaseVisibility() {
    if (!map) return;
    const isEnabled = voronoiLayerState.enabled;
    voronoiLayerState.polygons.forEach((polygon, index) => {
      if (!polygon) return;
      const shouldShow = isEnabled && shouldDisplayVoronoiPolygon(index);
      if (typeof polygon.setMap === 'function') {
        polygon.setMap(shouldShow ? map : null);
      }
      if (typeof polygon.setVisible === 'function') {
        polygon.setVisible(!!shouldShow);
      }
      if (shouldShow) {
        applyVoronoiBaseStyle(polygon);
      }
      const label = polygon.__voronoiLabel;
      if (label) {
        setVoronoiLabelMap(label, shouldShow && isEnabled ? map : null);
      }
    });
  }

  function extractLatLngFromGooglePosition(position) {
    if (!position) return null;
    try {
      const lat = typeof position.lat === 'function' ? position.lat() : position.lat;
      const lng = typeof position.lng === 'function' ? position.lng() : position.lng;
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return { lat, lng };
      }
    } catch (_) {
      /* ignore */
    }
    return null;
  }

  function getMarkerPositionForOffer(offer) {
    if (!offer || typeof offer !== 'object') {
      return null;
    }

    const marker = offer.marker;
    if (marker && typeof marker.getPosition === 'function') {
      const markerPosition = extractLatLngFromGooglePosition(marker.getPosition());
      if (markerPosition) {
        return markerPosition;
      }
    }

    const plotLat = Number(offer.plot?.lat);
    const plotLng = Number(offer.plot?.lng);
    if (Number.isFinite(plotLat) && Number.isFinite(plotLng)) {
      return { lat: plotLat, lng: plotLng };
    }

    const voronoiPoint = offer.voronoiPoint;
    if (voronoiPoint && Number.isFinite(voronoiPoint.lat) && Number.isFinite(voronoiPoint.lng)) {
      return { lat: voronoiPoint.lat, lng: voronoiPoint.lng };
    }

    return null;
  }

  function getMarkerPositionForDatasetEntry(entry) {
    if (!entry || typeof entry !== 'object') {
      return null;
    }

    const offerPosition = getMarkerPositionForOffer(entry.offer);
    if (offerPosition) {
      return offerPosition;
    }

    const datasetPosition = entry.position;
    if (datasetPosition && Number.isFinite(datasetPosition.lat) && Number.isFinite(datasetPosition.lng)) {
      return { lat: datasetPosition.lat, lng: datasetPosition.lng };
    }

    return null;
  }

  function getVoronoiDatasetOfferKey(entry) {
    if (!entry || !entry.offer) {
      return null;
    }
    const rawKey = entry.offer.key ?? entry.offer.id ?? entry.offer.plot?.id ?? null;
    return rawKey != null ? String(rawKey) : null;
  }

  function getVoronoiInspectorElements() {
    const container = document.getElementById('voronoiInspector');
    const list = document.getElementById('voronoiInspectorList');
    const emptyState = document.getElementById('voronoiInspectorEmpty');
    const summary = document.getElementById('voronoiInspectorSummary');
    const summaryAvg = document.getElementById('voronoiInspectorAvgValue');
    const summaryEstimate = document.getElementById('voronoiInspectorEstimateValue');
    const summaryBadge = document.getElementById('voronoiInspectorSummaryBadge');
    if (!container || !list || !emptyState) {
      return null;
    }
    return { container, list, emptyState, summary, summaryAvg, summaryEstimate, summaryBadge };
  }

  function extractPlotAreaFromOffer(offer) {
    if (!offer || typeof offer !== 'object') {
      return 0;
    }
    const plot = offer.plot || {};
    const candidates = [
      plot.pow_dzialki_m2_uldk,
      plot.powierzchnia,
      plot.powierzchnia_m2,
      plot.area,
      plot.areaM2,
      plot.powierzchniaDzialki,
      offer.area,
      offer.areaM2
    ];
    for (const candidate of candidates) {
      const value = Number(candidate);
      if (Number.isFinite(value) && value > 0) {
        return value;
      }
    }
    return 0;
  }

  function hideVoronoiTagInspector() {
    const elements = getVoronoiInspectorElements();
    if (!elements) return;
    const { container, list, emptyState, summary, summaryAvg, summaryEstimate, summaryBadge } = elements;
    list.innerHTML = '';
    const defaultMessage = emptyState.dataset.defaultMessage || emptyState.textContent || '';
    emptyState.textContent = defaultMessage;
    emptyState.hidden = false;
    if (summary) {
      summary.setAttribute('hidden', 'true');
    }
    if (summaryAvg) {
      summaryAvg.textContent = '—';
    }
    if (summaryEstimate) {
      summaryEstimate.textContent = '—';
    }
    if (summaryBadge) {
      summaryBadge.setAttribute('hidden', 'true');
    }
    container.setAttribute('hidden', 'true');
    container.setAttribute('aria-hidden', 'true');
  }

  function updateVoronoiTagInspector(index) {
    const elements = getVoronoiInspectorElements();
    if (!elements) return;
    const { container, list, emptyState, summary, summaryAvg, summaryEstimate, summaryBadge } = elements;

    if (!Number.isInteger(index) || index < 0) {
      hideVoronoiTagInspector();
      return;
    }

    const datasetEntry = Array.isArray(voronoiLayerState.datasetSnapshot)
      ? voronoiLayerState.datasetSnapshot[index]
      : null;
    const resolvedEntry = Array.isArray(voronoiLayerState.resolvedValues)
      ? voronoiLayerState.resolvedValues[index]
      : null;
    const offerTags = Array.isArray(datasetEntry?.offer?.tags)
      ? datasetEntry.offer.tags.filter(tag => typeof tag === 'string' && tag.trim().length)
      : [];

    container.removeAttribute('hidden');
    container.setAttribute('aria-hidden', 'false');
    list.innerHTML = '';

    if (summary) {
      const summaryData = (() => {
        if (!resolvedEntry) {
          return null;
        }
        let pricePerSqm = Number(resolvedEntry.pricePerSqm);
        let totalPrice = Number(resolvedEntry.price);
        let area = Number(resolvedEntry.area);
        if (!(area > 0)) {
          area = extractPlotAreaFromOffer(datasetEntry?.offer);
        }
        if (!(pricePerSqm > 0) && totalPrice > 0 && area > 0) {
          pricePerSqm = totalPrice / area;
        }
        if (!(totalPrice > 0) && pricePerSqm > 0 && area > 0) {
          totalPrice = pricePerSqm * area;
        }
        if (!(pricePerSqm > 0) && !(totalPrice > 0)) {
          return null;
        }
        return {
          pricePerSqm: pricePerSqm > 0 ? pricePerSqm : 0,
          totalPrice: totalPrice > 0 ? totalPrice : 0,
          fallback: Array.isArray(resolvedEntry.fallbackSources) && resolvedEntry.fallbackSources.length > 0
        };
      })();

      if (summaryData) {
        const avgText = summaryData.pricePerSqm > 0
          ? `${formatPriceValue(summaryData.pricePerSqm)} zł/m²`
          : '—';
        const totalText = summaryData.totalPrice > 0
          ? `${formatPriceValue(summaryData.totalPrice)} zł`
          : '—';
        summaryAvg && (summaryAvg.textContent = avgText);
        summaryEstimate && (summaryEstimate.textContent = totalText);
        if (summaryBadge) {
          if (summaryData.fallback) {
            summaryBadge.removeAttribute('hidden');
          } else {
            summaryBadge.setAttribute('hidden', 'true');
          }
        }
        summary.removeAttribute('hidden');
      } else {
        summary.setAttribute('hidden', 'true');
        summaryAvg && (summaryAvg.textContent = '—');
        summaryEstimate && (summaryEstimate.textContent = '—');
        summaryBadge && summaryBadge.setAttribute('hidden', 'true');
      }
    }

    if (!offerTags.length) {
      emptyState.textContent = 'Brak tagów dla tej działki.';
      emptyState.hidden = false;
      return;
    }

    emptyState.hidden = true;

    const uniqueTags = Array.from(new Set(offerTags));
    uniqueTags.sort((a, b) => a.localeCompare(b, 'pl', { sensitivity: 'base' }));

    const weightMap = voronoiLayerState.tagWeights instanceof Map
      ? voronoiLayerState.tagWeights
      : new Map();
    const maxValue = Math.max(Number(voronoiLayerState.maxTagValue) || 1, 1);
    const totalWeight = uniqueTags.reduce((sum, tag) => {
      const weight = Number(weightMap.get(tag));
      return sum + (Number.isFinite(weight) && weight > 0 ? weight : 0);
    }, 0);

    uniqueTags.forEach(tag => {
      const weight = Number(weightMap.get(tag)) || 0;
      const percentBase = totalWeight > 0 ? totalWeight : maxValue;
      const rawPercent = percentBase > 0 ? Math.round((weight / percentBase) * 100) : 0;
      const displayPercent = percentBase > 0 && weight > 0 ? Math.max(1, rawPercent) : 0;

      const item = document.createElement('li');
      item.className = 'voronoi-inspector__item';

      const tagLabel = document.createElement('span');
      tagLabel.className = 'voronoi-inspector__tag';
      tagLabel.textContent = formatTagLabel(tag);

      const value = document.createElement('span');
      value.className = 'voronoi-inspector__percentage';
      value.textContent = `${displayPercent}%`;

      item.appendChild(tagLabel);
      item.appendChild(value);
      list.appendChild(item);
    });
  }

  function clearVoronoiHighlights(options = {}) {
    const { resetSelection = true } = options || {};
    const highlight = voronoiLayerState.highlight;
    if (highlight.polygons.size) {
      highlight.polygons.forEach(polygon => applyVoronoiBaseStyle(polygon));
    }
    if (highlight.connectors.size) {
      highlight.connectors.forEach(connector => {
        applyVoronoiConnectorStyle(connector, 'default');
        if (connector && typeof connector.setMap === 'function') {
          connector.setMap(null);
        }
        if (connector && typeof connector.setVisible === 'function') {
          connector.setVisible(false);
        }
        if (connector?.__voronoiLabel) {
          setOverlayMap(connector.__voronoiLabel, null);
        }
      });
    }
    if (highlight.hiddenPolygons instanceof Map && highlight.hiddenPolygons.size) {
      highlight.hiddenPolygons.forEach((state, polygon) => {
        if (!polygon) return;
        const label = state?.label || null;
        if (typeof polygon.setMap === 'function') {
          const targetMap = state?.map && voronoiLayerState.enabled ? state.map : null;
          polygon.setMap(targetMap);
        }
        if (typeof polygon.setVisible === 'function') {
          polygon.setVisible(state?.visible !== false);
        }
        applyVoronoiBaseStyle(polygon);
        if (label) {
          const labelTargetMap = state?.labelMap && voronoiLayerState.enabled ? state.labelMap : null;
          setVoronoiLabelMap(label, labelTargetMap);
        }
      });
      highlight.hiddenPolygons.clear();
    }
    highlight.polygons.clear();
    highlight.connectors.clear();
    highlight.baseIndex = null;
    if (resetSelection) {
      highlight.selectedOfferKey = null;
      highlight.selectedIndexHint = null;
      highlight.ignoreNextMapClear = false;
      hideVoronoiTagInspector();
      voronoiLayerState.selectionLock = null;
    }
    if (voronoiLayerState.enabled) {
      applyVoronoiBaseVisibility();
    }
  }

  function highlightVoronoiPolygon(index) {
    if (!Number.isInteger(index) || index < 0) {
      return;
    }
    const polygon = voronoiLayerState.polygons[index];
    if (!polygon) {
      return;
    }
    if (!polygon.__voronoiIsAssigned) {
      return;
    }

    clearVoronoiHighlights({ resetSelection: false });

    const highlight = voronoiLayerState.highlight;
    const activeIndices = new Set([index]);
    applyVoronoiPolygonStyle(polygon, 'baseHighlight');
    if (map && typeof polygon.setMap === 'function') {
      polygon.setMap(map);
    }
    if (typeof polygon.setVisible === 'function') {
      polygon.setVisible(true);
    }
    if (polygon.__voronoiLabel) {
      setVoronoiLabelMap(polygon.__voronoiLabel, map);
    }
    highlight.polygons.add(polygon);
    highlight.baseIndex = index;
    highlight.selectedIndexHint = index;
    const datasetEntry = Array.isArray(voronoiLayerState.datasetSnapshot)
      ? voronoiLayerState.datasetSnapshot[index]
      : null;
    const offerKey = getVoronoiDatasetOfferKey(datasetEntry);
    highlight.selectedOfferKey = offerKey;

    const resolvedEntry = Array.isArray(voronoiLayerState.resolvedValues)
      ? voronoiLayerState.resolvedValues[index]
      : null;
    const fallbackSources = Array.isArray(resolvedEntry?.fallbackSources)
      ? resolvedEntry.fallbackSources
      : [];
    const uniqueSources = new Set();

    fallbackSources.forEach(source => {
      const resolvedSourceIndex = Number.isInteger(source?.sourceIndex)
        ? source.sourceIndex
        : (Array.isArray(source?.path) && source.path.length
          ? source.path[source.path.length - 1]
          : null);
      if (Number.isInteger(resolvedSourceIndex)) {
        uniqueSources.add(resolvedSourceIndex);
      }
    });

    uniqueSources.forEach(sourceIndex => {
      if (sourceIndex === index) return;
      const sourcePolygon = voronoiLayerState.polygons[sourceIndex];
      if (!sourcePolygon) return;
      applyVoronoiPolygonStyle(sourcePolygon, 'sourceHighlight');
      if (map && typeof sourcePolygon.setMap === 'function') {
        sourcePolygon.setMap(map);
      }
      if (typeof sourcePolygon.setVisible === 'function') {
        sourcePolygon.setVisible(true);
      }
      if (sourcePolygon.__voronoiLabel) {
        setVoronoiLabelMap(sourcePolygon.__voronoiLabel, map);
      }
      highlight.polygons.add(sourcePolygon);
      activeIndices.add(sourceIndex);
    });

    const connectorList = voronoiLayerState.connectorIndexMap instanceof Map
      ? voronoiLayerState.connectorIndexMap.get(index)
      : null;
    if (Array.isArray(connectorList)) {
      connectorList.forEach(connector => {
        applyVoronoiConnectorStyle(connector, 'highlight');
        if (connector && typeof connector.setMap === 'function' && voronoiLayerState.enabled && map) {
          connector.setMap(map);
        }
        if (connector && typeof connector.setVisible === 'function') {
          connector.setVisible(true);
        }
        if (connector?.__voronoiLabel && voronoiLayerState.enabled && map) {
          setOverlayMap(connector.__voronoiLabel, map);
        }
        highlight.connectors.add(connector);
      });
    }

    if (highlight.hiddenPolygons instanceof Map) {
      voronoiLayerState.polygons.forEach((poly, polyIndex) => {
        if (!poly || activeIndices.has(polyIndex)) {
          return;
        }
        if (!highlight.hiddenPolygons.has(poly)) {
          const currentMap = typeof poly.getMap === 'function' ? poly.getMap() : null;
          const currentVisible = typeof poly.getVisible === 'function' ? poly.getVisible() : true;
          const label = poly.__voronoiLabel || null;
          const labelMap = label ? getVoronoiLabelMap(label) : null;
          highlight.hiddenPolygons.set(poly, {
            map: currentMap,
            visible: currentVisible,
            label,
            labelMap
          });
        }
        if (typeof poly.setVisible === 'function') {
          poly.setVisible(false);
        }
        if (typeof poly.setMap === 'function') {
          poly.setMap(null);
        }
        const label = poly.__voronoiLabel;
        if (label) {
          setVoronoiLabelMap(label, null);
        }
      });
    }

    updateVoronoiSelectionLock(index);
    updateVoronoiTagInspector(index);
  }

  const VORONOI_FREEZE_ZOOM_LEVEL = 14;
  const VORONOI_HIDE_ZOOM_LEVEL = 19;
  const VORONOI_LABEL_BASE_MIN_ZOOM = 15;
  const VORONOI_LABEL_VISIBILITY_RULES = [
    { minCount: 260, minZoom: 18 },
    { minCount: 200, minZoom: 17 },
    { minCount: 150, minZoom: 16 },
    { minCount: 100, minZoom: 15 },
    { minCount: 60, minZoom: 15 }
  ];

  function getMapZoomLevel() {
    if (!map || typeof map.getZoom !== 'function') return null;
    const zoom = map.getZoom();
    return typeof zoom === 'number' ? zoom : null;
  }

  function shouldFreezeVoronoiLayout() {
    const zoom = getMapZoomLevel();
    return Number.isFinite(zoom) && zoom >= VORONOI_FREEZE_ZOOM_LEVEL;
  }

  function getActiveVoronoiSelectionLock() {
    const lock = voronoiLayerState.selectionLock;
    if (!lock || !lock.layout) {
      return null;
    }
    const highlightKey = voronoiLayerState.highlight.selectedOfferKey;
    if (!highlightKey || lock.offerKey !== highlightKey) {
      return null;
    }
    const offers = Array.isArray(lock.layout?.offers) ? lock.layout.offers : [];
    if (!offers.length) {
      return null;
    }
    return lock;
  }

  function shouldHideVoronoiLayer() {
    const zoom = getMapZoomLevel();
    return Number.isFinite(zoom) && zoom >= VORONOI_HIDE_ZOOM_LEVEL;
  }

  function cloneVoronoiPoint(point) {
    if (!point) return null;
    const lat = Number(point.lat);
    const lng = Number(point.lng);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return null;
    }
    return { lat, lng };
  }

  function cloneVoronoiPath(path) {
    if (!Array.isArray(path)) {
      return [];
    }
    return path
      .map(point => cloneVoronoiPoint(point))
      .filter(Boolean);
  }

  function cloneVoronoiCell(cell) {
    if (!cell) return null;
    const clonedPath = cloneVoronoiPath(cell.path);
    const centroid = cloneVoronoiPoint(cell.centroid);
    const position = cloneVoronoiPoint(cell.position);
    return {
      path: clonedPath,
      centroid: centroid || null,
      position: position || null
    };
  }

  function cloneVoronoiCache(dataset, adjacencyList, resolvedValues, extent, cells) {
    return {
      dataset: Array.isArray(dataset)
        ? dataset.map(entry => ({
            offer: entry.offer,
            position: entry?.position
              ? { lat: entry.position.lat, lng: entry.position.lng }
              : null
          }))
        : [],
      adjacencyList: Array.isArray(adjacencyList)
        ? adjacencyList.map(neighbors => Array.isArray(neighbors) ? neighbors.slice() : [])
        : [],
      resolvedValues: Array.isArray(resolvedValues)
        ? resolvedValues.map(value => {
            if (!value) return value;
            return {
              ...value,
              fallbackSources: Array.isArray(value.fallbackSources)
                ? value.fallbackSources.map(source => {
                    if (!source) {
                      return null;
                    }
                    const path = Array.isArray(source.path)
                      ? source.path.slice()
                      : [];
                    const sourceIndex = Number.isInteger(source.sourceIndex)
                      ? source.sourceIndex
                      : null;
                    const distanceMeters = Number.isFinite(source.distanceMeters)
                      ? source.distanceMeters
                      : null;
                    const weight = Number.isFinite(source.weight)
                      ? source.weight
                      : null;
                    return {
                      path,
                      sourceIndex,
                      distanceMeters,
                      weight
                    };
                  }).filter(Boolean)
                : []
            };
          })
        : [],
      extent: Array.isArray(extent) ? extent.slice() : null,
      cells: Array.isArray(cells)
        ? cells.map(cell => cloneVoronoiCell(cell))
        : []
    };
  }

  function cloneFrozenVoronoiLayout(dataset, adjacencyList, resolvedValues, extent, offers, signature, cells) {
    const cache = cloneVoronoiCache(dataset, adjacencyList, resolvedValues, extent, cells);
    return {
      ...cache,
      offers: Array.isArray(offers) ? offers.slice() : [],
      signature: typeof signature === 'string' ? signature : null
    };
  }

  function updateVoronoiSelectionLock(baseIndex) {
    if (!Number.isInteger(baseIndex) || baseIndex < 0) {
      return;
    }
    const dataset = Array.isArray(voronoiLayerState.datasetSnapshot)
      ? voronoiLayerState.datasetSnapshot
      : [];
    if (!dataset.length || baseIndex >= dataset.length) {
      return;
    }

    const entry = dataset[baseIndex];
    const offerKey = getVoronoiDatasetOfferKey(entry);
    if (!offerKey) {
      return;
    }

    const offers = dataset
      .map(item => item?.offer)
      .filter(Boolean);
    if (!offers.length) {
      return;
    }

    const signature = offers
      .map(offer => {
        const rawKey = offer?.key ?? offer?.id ?? offer?.plot?.id ?? '';
        return rawKey != null ? String(rawKey) : '';
      })
      .join('|');

    const extentSnapshot = Array.isArray(voronoiLayerState.currentExtent)
      ? voronoiLayerState.currentExtent.slice()
      : null;

    const adjacencyList = Array.isArray(voronoiLayerState.adjacencyList)
      ? voronoiLayerState.adjacencyList.map(neighbors => (
          Array.isArray(neighbors) ? neighbors.slice() : []
        ))
      : [];

    const layout = cloneFrozenVoronoiLayout(
      dataset,
      adjacencyList,
      voronoiLayerState.resolvedValues,
      extentSnapshot,
      offers,
      signature,
      voronoiLayerState.cells
    );

    voronoiLayerState.selectionLock = {
      baseIndex,
      offerKey,
      signature,
      layout
    };
  }

  function shouldRenderVoronoiLabelsForDatasetSize(count) {
    if (!Number.isFinite(count) || count <= 0) {
      return false;
    }
    if (count <= 20) {
      return true;
    }
    const zoom = getMapZoomLevel();
    if (!Number.isFinite(zoom)) {
      return false;
    }
    if (zoom < VORONOI_LABEL_BASE_MIN_ZOOM) {
      return false;
    }
    for (const rule of VORONOI_LABEL_VISIBILITY_RULES) {
      if (count >= rule.minCount && zoom < rule.minZoom) {
        return false;
      }
    }
    return true;
  }

  function determineVoronoiLabelDensity(count) {
    if (!Number.isFinite(count) || count <= 0) {
      return 'default';
    }
    const zoom = getMapZoomLevel();
    if (!Number.isFinite(zoom)) {
      return 'default';
    }

    if (count >= 150 && zoom <= 16) {
      return 'compact';
    }
    if (count >= 110 && zoom <= 15) {
      return 'compact';
    }
    if (count >= 80 && zoom <= 14) {
      return 'compact';
    }

    return 'default';
  }

  const MAP_STATE_STORAGE_KEY = 'grunteo::offers::mapState';
  const MAP_STATE_TTL_MS = 1000 * 60 * 60 * 12; // 12 godzin
  let pendingMapState = readStoredMapState();
  let mapStateViewApplied = false;

  function readStoredMapState() {
    if (typeof window === 'undefined' || !window.localStorage) return null;
    try {
      const raw = window.localStorage.getItem(MAP_STATE_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return null;
      const timestamp = Number(parsed.timestamp);
      if (Number.isFinite(timestamp) && MAP_STATE_TTL_MS > 0) {
        const age = Date.now() - timestamp;
        if (age > MAP_STATE_TTL_MS) {
          window.localStorage.removeItem(MAP_STATE_STORAGE_KEY);
          return null;
        }
      }
      return parsed;
    } catch (error) {
      console.warn('Nie udało się odczytać zapisanego stanu mapy ofert.', error);
      return null;
    }
  }

  function clearStoredMapState() {
    pendingMapState = null;
    try {
      window.localStorage?.removeItem(MAP_STATE_STORAGE_KEY);
    } catch (error) {
      console.warn('Nie udało się wyczyścić zapisanego stanu mapy ofert.', error);
    }
  }

  function saveMapState(extra = {}) {
    if (!map || typeof window === 'undefined' || !window.localStorage) return;
    const center = typeof map.getCenter === 'function' ? map.getCenter() : null;
    const lat = center && typeof center.lat === 'function' ? center.lat() : null;
    const lng = center && typeof center.lng === 'function' ? center.lng() : null;
    const zoom = typeof map.getZoom === 'function' ? map.getZoom() : null;

    const hasFocusOfferId = Object.prototype.hasOwnProperty.call(extra, 'focusOfferId');
    const hasFocusPlotIndex = Object.prototype.hasOwnProperty.call(extra, 'focusPlotIndex');

    const focusOfferId = hasFocusOfferId
      ? (typeof extra.focusOfferId === 'string' && extra.focusOfferId.trim()
        ? extra.focusOfferId.trim()
        : null)
      : (typeof pendingMapState?.focusOfferId === 'string' ? pendingMapState.focusOfferId : null);
    const focusPlotIndex = hasFocusPlotIndex
      ? (Number.isInteger(extra.focusPlotIndex) ? extra.focusPlotIndex : null)
      : (Number.isInteger(pendingMapState?.focusPlotIndex) ? pendingMapState.focusPlotIndex : null);

    const payload = {
      timestamp: Date.now(),
      center: Number.isFinite(lat) && Number.isFinite(lng) ? { lat, lng } : null,
      zoom: Number.isFinite(zoom) ? zoom : null,
      focusOfferId,
      focusPlotIndex
    };

    try {
      window.localStorage.setItem(MAP_STATE_STORAGE_KEY, JSON.stringify(payload));
      pendingMapState = payload;
    } catch (error) {
      console.warn('Nie udało się zapisać stanu mapy ofert.', error);
    }
  }

  function applySavedMapView() {
    if (!map || !pendingMapState || mapStateViewApplied) return;
    const { center, zoom, focusOfferId } = pendingMapState;
    const zoomValue = Number(zoom);
    if (Number.isFinite(zoomValue)) {
      map.setZoom(zoomValue);
    }
    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {
      map.setCenter({ lat: center.lat, lng: center.lng });
    }
    mapStateViewApplied = true;
    if (!focusOfferId) {
      clearStoredMapState();
    }
  }

  function focusOfferFromMapState() {
    if (!map || !pendingMapState || !pendingMapState.focusOfferId) return;
    const { focusOfferId } = pendingMapState;
    const focusPlotIndex = Number.isInteger(pendingMapState.focusPlotIndex)
      ? pendingMapState.focusPlotIndex
      : null;

    const match = allOffers.find(entry => {
      if (!entry || entry.id !== focusOfferId) return false;
      if (focusPlotIndex === null) return true;
      return entry.index === focusPlotIndex;
    }) || allOffers.find(entry => entry && entry.id === focusOfferId);

    if (match) {
      let focusPosition = null;
      if (match.marker && typeof match.marker.getPosition === 'function') {
        focusPosition = match.marker.getPosition();
      } else if (match.plot && Number.isFinite(match.plot.lat) && Number.isFinite(match.plot.lng)) {
        focusPosition = { lat: match.plot.lat, lng: match.plot.lng };
      }

      const hasSavedCenter = pendingMapState?.center
        && Number.isFinite(pendingMapState.center.lat)
        && Number.isFinite(pendingMapState.center.lng);
      const shouldRespectSavedView = mapStateViewApplied && hasSavedCenter;

      try {
        if (focusPosition && typeof map.panTo === 'function' && !shouldRespectSavedView) {
          map.panTo(focusPosition);
        }
      } catch (error) {
        console.warn('Nie udało się przesunąć mapy do zapamiętanej oferty.', error);
      }

      const anchor = match.marker && typeof match.marker.getPosition === 'function'
        ? match.marker
        : focusPosition;
      openInfo(anchor, infoHTML(match.plot, match.data, match.id, match.index), {
        offerId: typeof match.id === 'string' ? match.id : null,
        plotIndex: Number.isInteger(match.index) ? match.index : null,
        skipMapStateUpdate: true
      });
      document.querySelector('.map-container')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    clearStoredMapState();
  }

  document.addEventListener('click', (event) => {
    const link = event.target?.closest?.('a[data-preserve-map-state]');
    if (!link) return;
    const offerId = typeof link.dataset.offerId === 'string' ? link.dataset.offerId : null;
    const plotIndexRaw = link.dataset.plotIndex;
    const hasPlotIndex = plotIndexRaw !== undefined && plotIndexRaw !== '';
    const plotIndex = hasPlotIndex ? Number(plotIndexRaw) : null;
    saveMapState({
      focusOfferId: offerId || null,
      focusPlotIndex: Number.isInteger(plotIndex) ? plotIndex : null
    });
  }, true);

  const OFFERS_CACHE_KEY = typeof window !== 'undefined' && window.__OFFERS_CACHE_KEY__
    ? window.__OFFERS_CACHE_KEY__
    : 'grunteo::offers-cache::v1';

  const OFFERS_CACHE_SENSITIVE_FIELDS = ['userEmail', 'userUid'];

  function resolveOffersCacheSettings() {
    const revision = typeof window.__OFFERS_REVISION_HINT__ === 'string'
      ? window.__OFFERS_REVISION_HINT__.trim()
      : '';
    const ttlCandidate = Number(window.__OFFERS_CACHE_TTL_MS__);
    const ttlMs = Number.isFinite(ttlCandidate) && ttlCandidate > 0
      ? ttlCandidate
      : null; // brak ustawienia TTL wyłącza cache, jeśli config nie został załadowany

    const pageSizeCandidate = Number(window.__OFFERS_PAGE_SIZE__);
    const maxPagesCandidate = Number(window.__OFFERS_MAX_PAGES__);
    const staleAfterCandidate = Number(window.__OFFERS_STALE_AFTER_MS__);

    return {
      revisionHint: revision || null,
      ttlMs,
      pageSize: Number.isFinite(pageSizeCandidate) && pageSizeCandidate > 0 ? Math.floor(pageSizeCandidate) : null,
      maxPages: Number.isFinite(maxPagesCandidate) && maxPagesCandidate > 0 ? Math.floor(maxPagesCandidate) : null,
      staleAfterMs: Number.isFinite(staleAfterCandidate) && staleAfterCandidate > 0 ? staleAfterCandidate : null
    };
  }

  function clearOffersCache() {
    try {
      window.localStorage?.removeItem(OFFERS_CACHE_KEY);
    } catch (_) {
      /* ignore */
    }
  }

  function cloneForCache(value) {
    try {
      return JSON.parse(JSON.stringify(value ?? null));
    } catch (error) {
      console.warn('Nie udało się sklonować danych oferty do cache:', error);
      return null;
    }
  }

  function getActivePlotEntries(rawPlots) {
    if (!Array.isArray(rawPlots)) return [];
    const result = [];
    rawPlots.forEach((plot, index) => {
      if (!plot || typeof plot !== 'object') return;
      if (plot.mock === false) return;

      const normalizedPlot = { ...plot };
      if (typeof normalizedPlot.mock === 'undefined') {
        normalizedPlot.mock = true;
      }

      const storedIndex = Number.isInteger(plot.__originalIndex)
        ? plot.__originalIndex
        : Number.isInteger(normalizedPlot.__originalIndex)
          ? normalizedPlot.__originalIndex
          : index;

      delete normalizedPlot.__originalIndex;

      result.push({
        plot: normalizedPlot,
        originalIndex: storedIndex
      });
    });
    return result;
  }

  function getInactivePlotEntries(rawPlots) {
    if (!Array.isArray(rawPlots)) return [];
    const result = [];
    rawPlots.forEach((plot, index) => {
      if (!plot || typeof plot !== 'object') return;
      if (plot.mock !== false) return;

      const normalizedPlot = { ...plot };
      normalizedPlot.mock = false;

      const storedIndex = Number.isInteger(plot.__originalIndex)
        ? plot.__originalIndex
        : Number.isInteger(normalizedPlot.__originalIndex)
          ? normalizedPlot.__originalIndex
          : index;

      delete normalizedPlot.__originalIndex;

      result.push({
        plot: normalizedPlot,
        originalIndex: storedIndex
      });
    });
    return result;
  }

  function preparePlotsForCache(rawPlots) {
    return getActivePlotEntries(rawPlots)
      .map(({ plot, originalIndex }) => {
        const safePlot = cloneForCache(plot) || { ...plot };
        if (!safePlot || typeof safePlot !== 'object') {
          return null;
        }
        if (typeof safePlot.mock === 'undefined') {
          safePlot.mock = true;
        }
        safePlot.__originalIndex = originalIndex;
        return safePlot;
      })
      .filter(Boolean);
  }

  function prepareInactivePlotsForCache(rawPlots) {
    return getInactivePlotEntries(rawPlots)
      .map(({ plot, originalIndex }) => {
        const safePlot = cloneForCache(plot) || { ...plot };
        if (!safePlot || typeof safePlot !== 'object') {
          return null;
        }
        safePlot.mock = false;
        safePlot.__originalIndex = originalIndex;
        return safePlot;
      })
      .filter(Boolean);
  }

  function sanitizeOfferDocumentForCache(doc) {
    if (!doc || typeof doc !== 'object') return null;

    const id = doc?.id || null;
    const rawData = doc?.data || {};
    const clonedData = cloneForCache(rawData) || { ...rawData };
    if (!clonedData || typeof clonedData !== 'object') {
      return null;
    }
    if (clonedData.mock === false) {
      return null;
    }

    OFFERS_CACHE_SENSITIVE_FIELDS.forEach((field) => {
      if (field in clonedData) {
        delete clonedData[field];
      }
    });

    const normalizedPlots = preparePlotsForCache(clonedData.plots);
    if (!normalizedPlots.length) {
      return null;
    }

    clonedData.plots = normalizedPlots;

    const inactivePlots = prepareInactivePlotsForCache(rawData.plots);
    if (inactivePlots.length) {
      clonedData.__inactivePlots = inactivePlots;
    } else if (clonedData.__inactivePlots) {
      delete clonedData.__inactivePlots;
    }

    return {
      id,
      data: clonedData
    };
  }

  function toTimestampMillis(value) {
    if (value === null || value === undefined) {
      return null;
    }
    if (value instanceof Date) {
      const time = value.getTime();
      return Number.isNaN(time) ? null : time;
    }
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value === 'string') {
      const parsed = Date.parse(value);
      return Number.isNaN(parsed) ? null : parsed;
    }
    if (typeof value === 'object') {
      if (typeof value.toDate === 'function') {
        try {
          const date = value.toDate();
          return date instanceof Date && !Number.isNaN(date.getTime()) ? date.getTime() : null;
        } catch (_) {
          return null;
        }
      }
      if (typeof value.seconds === 'number') {
        const baseMs = value.seconds * 1000;
        const nanos = Number(value.nanoseconds);
        return Number.isFinite(baseMs) ? baseMs + (Number.isFinite(nanos) ? Math.floor(nanos / 1e6) : 0) : null;
      }
    }
    return null;
  }

  function getOfferUpdatedAtMillis(entry) {
    if (!entry || typeof entry !== 'object') {
      return null;
    }
    const data = entry.data || {};
    const candidates = [
      data.updatedAt,
      data.timestamp,
      data.createdAt,
      data.created_at,
      data.modifiedAt
    ];
    for (const candidate of candidates) {
      const ts = toTimestampMillis(candidate);
      if (ts !== null) {
        return ts;
      }
    }
    if (Array.isArray(data.plots)) {
      for (const plot of data.plots) {
        const plotCandidates = [plot?.updatedAt, plot?.timestamp, plot?.priceUpdatedAt];
        for (const candidate of plotCandidates) {
          const ts = toTimestampMillis(candidate);
          if (ts !== null) {
            return ts;
          }
        }
      }
    }
    return null;
  }

  function computeLatestUpdatedAt(documents) {
    if (!Array.isArray(documents) || !documents.length) {
      return null;
    }
    let maxTs = null;
    documents.forEach((entry) => {
      const ts = getOfferUpdatedAtMillis(entry);
      if (ts !== null && (maxTs === null || ts > maxTs)) {
        maxTs = ts;
      }
    });
    return maxTs;
  }

  function readOffersCache(settings, { allowExpired = false } = {}) {
    if (!window.localStorage) {
      return null;
    }

    let raw = null;
    try {
      raw = window.localStorage.getItem(OFFERS_CACHE_KEY);
    } catch (error) {
      console.warn('Nie udało się odczytać cache ofert:', error);
      return null;
    }

    if (!raw) {
      return null;
    }

    let parsed;
    try {
      parsed = JSON.parse(raw);
    } catch (error) {
      console.warn('Niepoprawny cache ofert – czyszczę.', error);
      clearOffersCache();
      return null;
    }

    if (!parsed || typeof parsed !== 'object' || !Array.isArray(parsed.documents)) {
      return null;
    }

    const revisionHint = settings?.revisionHint || null;
    if (revisionHint) {
      if (!parsed.revisionHint || parsed.revisionHint !== revisionHint) {
        clearOffersCache();
        return null;
      }
    }

    const now = Date.now();
    const expiresAt = typeof parsed.expiresAt === 'string'
      ? Number(parsed.expiresAt)
      : parsed.expiresAt;
    if (!allowExpired && Number.isFinite(expiresAt) && expiresAt <= now) {
      clearOffersCache();
      return null;
    }

    const sanitizedDocuments = Array.isArray(parsed.documents)
      ? parsed.documents
          .map(sanitizeOfferDocumentForCache)
          .filter(Boolean)
      : [];

    const storedAt = Number(parsed.storedAt);
    const expiresAtNormalized = Number(parsed.expiresAt);
    const latestUpdatedAtCandidate = Number(parsed.latestUpdatedAt);

    const sanitizedPayload = {
      ...parsed,
      storedAt: Number.isFinite(storedAt) ? storedAt : null,
      expiresAt: Number.isFinite(expiresAtNormalized) ? expiresAtNormalized : null,
      latestUpdatedAt: Number.isFinite(latestUpdatedAtCandidate)
        ? latestUpdatedAtCandidate
        : computeLatestUpdatedAt(sanitizedDocuments),
      documents: sanitizedDocuments
    };

    try {
      window.localStorage.setItem(OFFERS_CACHE_KEY, JSON.stringify(sanitizedPayload));
    } catch (_) {
      /* ignore */
    }

    return sanitizedPayload;
  }

  function writeOffersCache(documents, settings, metadata = {}) {
    if (!window.localStorage) {
      return;
    }

    try {
      const safeDocuments = Array.isArray(documents)
        ? documents
            .map(sanitizeOfferDocumentForCache)
            .filter(Boolean)
        : [];

      const now = Date.now();
      const ttl = Number(settings?.ttlMs);
      const payload = {
        revisionHint: settings?.revisionHint || null,
        storedAt: now,
        ttlMs: Number.isFinite(ttl) && ttl > 0 ? ttl : null,
        expiresAt: Number.isFinite(ttl) && ttl > 0 ? now + ttl : null,
        latestUpdatedAt: Number.isFinite(metadata?.latestUpdatedAt)
          ? metadata.latestUpdatedAt
          : computeLatestUpdatedAt(safeDocuments),
        documents: safeDocuments
      };

      window.localStorage.setItem(OFFERS_CACHE_KEY, JSON.stringify(payload));
    } catch (error) {
      console.warn('Nie udało się zapisać cache ofert:', error);
    }
  }

  function shouldRefreshOffersCache(cacheEntry, settings, { forceRefresh = false } = {}) {
    if (forceRefresh) {
      return true;
    }
    if (!cacheEntry) {
      return true;
    }

    const now = Date.now();
    const revisionFromCache = typeof cacheEntry.revisionHint === 'string' ? cacheEntry.revisionHint : null;
    const revisionFromConfig = typeof settings?.revisionHint === 'string' ? settings.revisionHint : null;
    if (revisionFromConfig && revisionFromCache && revisionFromConfig !== revisionFromCache) {
      return true;
    }

    const expiresAt = Number(cacheEntry.expiresAt);
    if (Number.isFinite(expiresAt) && expiresAt <= now) {
      return true;
    }

    const staleAfter = Number(settings?.staleAfterMs);
    const storedAt = Number(cacheEntry.storedAt);
    if (Number.isFinite(staleAfter) && staleAfter > 0 && Number.isFinite(storedAt) && storedAt + staleAfter <= now) {
      return true;
    }

    return false;
  }

  function hydrateOffersFromDocuments(documents) {
    const listContainer = document.getElementById("offersList");
    if (listContainer) listContainer.innerHTML = "";

    allOffers.forEach(offer => {
      if (offer.marker) offer.marker.setMap(null);
      if (offer.polygon) offer.polygon.setMap(null);
    });

    markers.forEach(marker => marker.setMap(null));
    markers = [];
    allOffers = [];
    availableTags = [];
    tagMetrics = new Map();
    currentVisibleOffers = [];
    voronoiSupplementaryOffers = [];
    currentVoronoiOffers = [];
    currentVoronoiSupplementary = [];
    voronoiHiddenOffersInBounds = [];
    voronoiSupplementaryOffersInBounds = [];
    clearVoronoiIndicators();
    voronoiLayerState.cachedDataset = null;
    voronoiLayerState.cacheSignature = null;
    voronoiLayerState.frozenLayout = null;
    voronoiLayerState.selectionLock = null;
    voronoiLayerState.adjacencyList = [];
    voronoiLayerState.currentExtent = null;
    voronoiLayerState.lastNonFrozenSource = {
      offers: [],
      signature: null,
      extent: null
    };

    if (!Array.isArray(documents)) {
      renderTagFilters();
      updateSortButtonsUI();
      applyFilters();
      return;
    }

    documents.forEach(entry => {
      const offerId = entry?.id || null;
      const data = entry?.data || {};
      const activePlots = getActivePlotEntries(data.plots);
      if (!activePlots.length) return;

      activePlots.forEach(({ plot, originalIndex }) => {

        const lat = Number(plot.lat);
        const lng = Number(plot.lng);
        const geometry = plot.geometry_uldk;
        const tags = normalizeTags(plot.tags);
        const uniquePlotTags = Array.from(new Set(tags));

        const baseVoronoiPoint = Number.isFinite(lat) && Number.isFinite(lng)
          ? { lat, lng }
          : null;

        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
          return;
        }

        const marker = new google.maps.Marker({
          position: { lat, lng },
          map,
          title: data.firstName || "Oferta",
          icon: { url: "https://maps.google.com/mapfiles/ms/icons/red-dot.png" }
        });
        markers.push(marker);

        marker.addListener('click', () => {
          if (map && typeof marker.getPosition === 'function') {
            panMapTo(marker.getPosition(), 17);
          }
          openInfo(marker, infoHTML(plot, data, offerId, originalIndex), {
            offerId: typeof offerId === 'string' ? offerId : null,
            plotIndex: Number.isInteger(originalIndex) ? originalIndex : null
          });
        });

        let polygon = null;
        let polygonCoords = [];
        let voronoiPoint = baseVoronoiPoint;
        if (geometry) {
          const coords = parseGeometry(geometry);
          if (coords.length) {
            polygonCoords = coords;
            polygon = new google.maps.Polygon({
              paths: coords,
              strokeColor: "#FF0000",
              strokeOpacity: 0.9,
              strokeWeight: 3,
              fillColor: "#FF0000",
              fillOpacity: 0.15,
              map: null,
              visible: false
            });
            polygon.addListener('click', (evt) => {
              const position = evt?.latLng || null;
              if (map && position) {
                panMapTo(position, 17);
              }
              openInfo(position, infoHTML(plot, data, offerId, originalIndex), {
                offerId: typeof offerId === 'string' ? offerId : null,
                plotIndex: Number.isInteger(originalIndex) ? originalIndex : null
              });
            });

            const interiorPoint = getPolygonInteriorPoint(coords, baseVoronoiPoint);
            if (interiorPoint) {
              voronoiPoint = interiorPoint;
            }
          }
        }

        const hydratedEntry = {
          id: offerId,
          key: `${offerId || 'unknown'}__${originalIndex}`,
          data,
          plot,
          index: originalIndex,
          marker,
          polygon,
          polygonCoords,
          voronoiPoint,
          tags: uniquePlotTags
        };

        allOffers.push(hydratedEntry);
      });

      const inactivePlots = Array.isArray(data.__inactivePlots)
        ? data.__inactivePlots
        : [];
      inactivePlots.forEach((inactivePlot, inactiveIndex) => {
        if (!inactivePlot || typeof inactivePlot !== 'object') {
          return;
        }

        const normalizedPlot = { ...inactivePlot };
        if (typeof normalizedPlot.mock === 'undefined') {
          normalizedPlot.mock = false;
        } else {
          normalizedPlot.mock = false;
        }

        const storedIndex = Number.isInteger(inactivePlot.__originalIndex)
          ? inactivePlot.__originalIndex
          : Number.isInteger(normalizedPlot.__originalIndex)
            ? normalizedPlot.__originalIndex
            : inactiveIndex;

        delete normalizedPlot.__originalIndex;

        let lat = Number(normalizedPlot.lat);
        let lng = Number(normalizedPlot.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
          return;
        }

        let voronoiPoint = { lat, lng };
        let polygonCoords = [];
        const geometry = normalizedPlot.geometry_uldk;
        if (geometry) {
          const coords = parseGeometry(geometry);
          if (coords.length) {
            polygonCoords = coords;
            const interiorPoint = getPolygonInteriorPoint(coords, voronoiPoint);
            if (interiorPoint) {
              voronoiPoint = interiorPoint;
            }
          }
        }

        const tags = normalizeTags(normalizedPlot.tags);
        const uniquePlotTags = Array.from(new Set(tags));

        const normalizedIndex = Number.isInteger(storedIndex)
          ? storedIndex
          : voronoiSupplementaryOffers.length + inactiveIndex;

        const supplementaryEntry = {
          id: offerId,
          key: `${offerId || 'unknown'}__inactive__${normalizedIndex}`,
          data,
          plot: normalizedPlot,
          index: normalizedIndex,
          marker: null,
          polygon: null,
          polygonCoords,
          voronoiPoint,
          tags: uniquePlotTags
        };

        voronoiSupplementaryOffers.push(supplementaryEntry);
      });
    });

    availableTags = [];
    randomPreviewSignature = '';
    randomPreviewTags = [];
    tagsExpanded = false;
    generateRandomTagWeightsFromOffers();
    renderTagFilters();
    updateSortButtonsUI();
    applyFilters();

    if (voronoiLayerState.enabled) {
      updateVoronoiLayer(true);
    }

    if (pendingMapState && pendingMapState.focusOfferId) {
      focusOfferFromMapState();
    }
  }

  async function refreshOffersFromSource(settings, options = {}) {
    const { cachedPayload = null } = options || {};
    const collectionRef = window.collection(window.db, "propertyListings");

    const cachedDocuments = Array.isArray(cachedPayload?.documents)
      ? cachedPayload.documents
      : [];
    const mergedMap = new Map();
    cachedDocuments.forEach((entry) => {
      if (entry && entry.id) {
        mergedMap.set(entry.id, entry);
      }
    });

    const pageSize = Number.isFinite(settings?.pageSize) && settings.pageSize > 0
      ? settings.pageSize
      : 200;
    const maxPages = Number.isFinite(settings?.maxPages) && settings.maxPages > 0
      ? settings.maxPages
      : 5;

    const latestCachedUpdate = Number(cachedPayload?.latestUpdatedAt);
    const hasLatestTimestamp = Number.isFinite(latestCachedUpdate) && latestCachedUpdate > 0 && window.Timestamp;

    const baseConstraints = [];
    if (hasLatestTimestamp) {
      // Wymagany indeks: propertyListings.updatedAt ASC (pojedyncze pole wystarcza).
      baseConstraints.push(window.where('updatedAt', '>', window.Timestamp.fromMillis(latestCachedUpdate)));
      baseConstraints.push(window.orderBy('updatedAt', 'asc'));
    } else {
      baseConstraints.push(window.orderBy('updatedAt', 'desc'));
    }

    let cursor = null;
    let fetchedPages = 0;
    let fetchedDocuments = 0;

    while (fetchedPages < maxPages) {
      const constraints = [...baseConstraints];
      if (cursor) {
        constraints.push(window.startAfter(cursor));
      }
      constraints.push(window.limit(pageSize));

      const q = window.query(collectionRef, ...constraints);
      const snapshot = await window.getDocs(q);
      if (snapshot.empty) {
        break;
      }

      snapshot.forEach((docSnap) => {
        fetchedDocuments += 1;
        const sanitized = sanitizeOfferDocumentForCache({ id: docSnap.id, data: docSnap.data() });
        if (sanitized) {
          mergedMap.set(docSnap.id, sanitized);
        } else {
          mergedMap.delete(docSnap.id);
        }
      });

      cursor = snapshot.docs[snapshot.docs.length - 1] || null;
      fetchedPages += 1;

      if (snapshot.size < pageSize) {
        break;
      }
    }

    if (!fetchedDocuments && !mergedMap.size && !hasLatestTimestamp) {
      // Kolekcja jest pusta lub dokumenty nie posiadają pola updatedAt – wykonujemy
      // awaryjne zapytanie bez sortowania po updatedAt.
      const fallbackSnapshot = await window.getDocs(collectionRef);
      fallbackSnapshot.forEach((docSnap) => {
        const sanitized = sanitizeOfferDocumentForCache({ id: docSnap.id, data: docSnap.data() });
        if (sanitized) {
          mergedMap.set(docSnap.id, sanitized);
        }
      });
    }

    const mergedDocuments = Array.from(mergedMap.values()).sort((a, b) => {
      const aTs = getOfferUpdatedAtMillis(a) || 0;
      const bTs = getOfferUpdatedAtMillis(b) || 0;
      if (aTs === bTs) {
        return (a.id || '').localeCompare(b.id || '');
      }
      return bTs - aTs;
    });

    hydrateOffersFromDocuments(mergedDocuments);
    writeOffersCache(mergedDocuments, settings, {
      latestUpdatedAt: computeLatestUpdatedAt(mergedDocuments)
    });
  }

  const tagFiltersList = document.getElementById('tagFiltersList');
  const toggleTagsBtn = document.getElementById('toggleTagsBtn');
  const sortButtons = document.querySelectorAll('[data-sort-key]');
  const voronoiToggleInput = document.getElementById('toggleVoronoiLayer');
  const voronoiToggleButtons = document.querySelectorAll('[data-voronoi-toggle]');

  function syncVoronoiToggleUI() {
    if (!voronoiToggleButtons?.length) {
      return;
    }
    const isEnabled = !!voronoiToggleInput?.checked;
    voronoiToggleButtons.forEach(button => {
      const shouldEnable = button.dataset.voronoiToggle === 'on';
      const isActive = shouldEnable === isEnabled;
      button.classList.toggle('voronoi-toggle__option--active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  const clusterRenderer = {
    render: ({ count, position }) => {
      return new google.maps.Marker({
        position,
        label: { text: String(count), color: 'white', fontSize: '14px', fontWeight: 'bold' },
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 20,
          fillColor: 'red',
          fillOpacity: 0.85,
          strokeColor: 'red',
          strokeWeight: 2
        }
      });
    }
  };

  toggleTagsBtn?.addEventListener('click', () => {
    tagsExpanded = !tagsExpanded;
    renderTagFilters();
  });

  sortButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const key = btn.dataset.sortKey;
      if (!key) return;
      if (filterState.sortKey === key) {
        filterState.sortDir = filterState.sortDir === 'asc' ? 'desc' : 'asc';
      } else {
        filterState.sortKey = key;
        filterState.sortDir = 'asc';
      }
      updateSortButtonsUI();
      filterOffersByBounds();
    });
  });

  voronoiToggleInput?.addEventListener('change', () => {
    voronoiLayerState.enabled = !!voronoiToggleInput.checked;
    if (voronoiLayerState.enabled) {
      if (!voronoiLayerState.tagWeights.size) {
        generateRandomTagWeightsFromOffers();
      }
      updateVoronoiLayer(true);
    } else {
      clearVoronoiLayer();
    }
    refreshVoronoiIndicators();
    syncVoronoiToggleUI();
  });

  if (voronoiToggleButtons?.length) {
    voronoiToggleButtons.forEach(button => {
      button.addEventListener('click', () => {
        if (!voronoiToggleInput) {
          return;
        }
        const shouldEnable = button.dataset.voronoiToggle === 'on';
        if (voronoiToggleInput.checked !== shouldEnable) {
          voronoiToggleInput.checked = shouldEnable;
          voronoiToggleInput.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          syncVoronoiToggleUI();
        }
      });
    });
  }

  syncVoronoiToggleUI();

  updateSortButtonsUI();

  // jedno, globalne InfoWindow – NIGDY nie tworzymy wielu
  window.infoWin = null;

  // ====== HELPERS ======
  function formatPhone(phone) {
    const digits = String(phone || "").replace(/\D/g, "");
    const core = digits.length >= 9 ? digits.slice(-9) : digits;
    if (core.length === 9) {
      return `+48 ${core.slice(0,3)}-${core.slice(3,6)}-${core.slice(6)}`;
    }
    return "";
  }

  function pickDisplayValue(values, fallback = "") {
    for (const value of values) {
      if (typeof value !== "string") continue;
      const trimmed = value.trim();
      if (trimmed) return trimmed;
    }
    return fallback;
  }

  function infoHTML(plot, data, offerId, plotIndex) {
    const price = Number(plot.price || 0);
    const area  = Number(plot.pow_dzialki_m2_uldk || 0);
    const ppm2  = price && area ? (price/area).toFixed(0) : null;
    const locationLabel = pickDisplayValue(
      [plot.location, plot.city, data.city, data.location],
      "brak"
    );
    const rawName = typeof data.firstName === "string" ? data.firstName.trim() : "";
    const shortName = rawName ? rawName.split(/\s+/)[0] : "";
    const phone = formatPhone(data.phone);
    const detailsUrl = `details.html?id=${offerId}&plot=${plotIndex}`;

    return `
      <div class="map-info-window">
        <h3>${plot.Id || "Brak identyfikatora"}</h3>
        <p><b>Miejscowość:</b> ${locationLabel}</p>
        ${price ? `<p><b>Cena:</b> ${price.toLocaleString('pl-PL')} zł${ppm2 ? ` <span style="color:#718096;">(${ppm2} zł/m²)</span>` : ''}</p>` : ''}
        ${area  ? `<p><b>Powierzchnia:</b> ${area.toLocaleString('pl-PL')} m²</p>` : ''}
        ${shortName ? `<p><b>Imię:</b> ${shortName}</p>` : ''}
        <p><b>Telefon:</b> ${phone || 'brak'}</p>
        <div class="mini-actions center">
          <a
            class="btn-mini"
            href="${detailsUrl}"
            data-preserve-map-state="true"
            ${offerId ? `data-offer-id="${offerId}"` : ''}
            ${Number.isInteger(plotIndex) ? `data-plot-index="${plotIndex}"` : ''}
          >Szczegóły</a>
        </div>
      </div>
    `;
  }

  function normalizeTags(rawTags) {
    if (!Array.isArray(rawTags)) return [];
    return rawTags
      .map(tag => (typeof tag === 'string' ? tag.trim() : String(tag || '').trim()))
      .filter(tag => tag.length);
  }

  function randomBetween(min, max) {
    const lower = Math.ceil(Math.min(min, max));
    const upper = Math.floor(Math.max(min, max));
    return Math.floor(Math.random() * (upper - lower + 1)) + lower;
  }

  function generateRandomTagWeightsFromOffers() {
    const uniqueTags = new Set();
    allOffers.forEach(offer => {
      if (Array.isArray(offer.tags)) {
        offer.tags.forEach(tag => {
          if (tag) uniqueTags.add(tag);
        });
      }
    });
    voronoiSupplementaryOffers.forEach(offer => {
      if (Array.isArray(offer.tags)) {
        offer.tags.forEach(tag => {
          if (tag) uniqueTags.add(tag);
        });
      }
    });

    const tags = Array.from(uniqueTags);
    const maxValue = tags.length || 1;
    const weights = new Map();
    tags.forEach(tag => {
      weights.set(tag, randomBetween(1, maxValue));
    });

    voronoiLayerState.tagWeights = weights;
    voronoiLayerState.maxTagValue = Math.max(maxValue, 1);
  }

  function computeTagFactor(tags) {
    if (!Array.isArray(tags) || !tags.length) return 1;
    if (!voronoiLayerState.tagWeights.size) {
      generateRandomTagWeightsFromOffers();
    }
    const weights = tags
      .map(tag => voronoiLayerState.tagWeights.get(tag) || 1);
    const maxWeight = Math.max(voronoiLayerState.maxTagValue, 1);
    const average = weights.reduce((sum, value) => sum + value, 0) / weights.length;
    const normalized = average / maxWeight;
    return 0.75 + normalized * 0.5;
  }

  function computeOfferValueWithTags(offer) {
    const price = Number(offer?.plot?.price);
    const area = Number(offer?.plot?.pow_dzialki_m2_uldk);
    const hasBasePrice = Number.isFinite(price) && price > 0;
    const adjustedPrice = hasBasePrice ? price * computeTagFactor(offer?.tags) : 0;
    const sanitizedArea = area && area > 0 ? area : 0;

    if (adjustedPrice > 0) {
      const ppm2 = sanitizedArea > 0 ? adjustedPrice / sanitizedArea : 0;
      return {
        price: adjustedPrice,
        pricePerSqm: ppm2 > 0 ? ppm2 : 0,
        area: sanitizedArea,
        hasPrice: true
      };
    }

    return { price: 0, pricePerSqm: 0, area: sanitizedArea, hasPrice: false };
  }

  function toRadians(degrees) {
    return (degrees * Math.PI) / 180;
  }

  function computeDistanceBetweenPoints(a, b) {
    if (!a || !b) return Infinity;
    const lat1 = Number(a.lat);
    const lng1 = Number(a.lng);
    const lat2 = Number(b.lat);
    const lng2 = Number(b.lng);
    if (!Number.isFinite(lat1) || !Number.isFinite(lng1) || !Number.isFinite(lat2) || !Number.isFinite(lng2)) {
      return Infinity;
    }
    const earthRadius = 6371000; // metry
    const dLat = toRadians(lat2 - lat1);
    const dLng = toRadians(lng2 - lng1);
    const rLat1 = toRadians(lat1);
    const rLat2 = toRadians(lat2);
    const aVal = Math.sin(dLat / 2) ** 2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLng / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(aVal), Math.sqrt(1 - aVal));
    return earthRadius * c;
  }

  function computePathDistance(path, dataset) {
    if (!Array.isArray(path) || path.length < 2 || !Array.isArray(dataset)) {
      return Infinity;
    }
    let total = 0;
    for (let i = 1; i < path.length; i++) {
      const prev = dataset[path[i - 1]]?.position || null;
      const next = dataset[path[i]]?.position || null;
      const segment = computeDistanceBetweenPoints(prev, next);
      if (!Number.isFinite(segment)) {
        return Infinity;
      }
      total += segment;
    }
    return total;
  }

  function computeConnectorMidpoint(path) {
    if (!Array.isArray(path) || path.length === 0) {
      return null;
    }
    if (path.length === 1) {
      return path[0];
    }

    let totalDistance = 0;
    const segments = [];
    for (let i = 1; i < path.length; i++) {
      const start = path[i - 1];
      const end = path[i];
      const segmentDistance = computeDistanceBetweenPoints(start, end);
      if (!Number.isFinite(segmentDistance) || segmentDistance <= 0) {
        continue;
      }
      segments.push({ start, end, distance: segmentDistance });
      totalDistance += segmentDistance;
    }

    if (!segments.length || !(totalDistance > 0)) {
      const first = path[0];
      const last = path[path.length - 1];
      if (first && last) {
        return {
          lat: (Number(first.lat) + Number(last.lat)) / 2,
          lng: (Number(first.lng) + Number(last.lng)) / 2
        };
      }
      return first || null;
    }

    const half = totalDistance / 2;
    let accumulated = 0;

    for (const segment of segments) {
      if (accumulated + segment.distance >= half) {
        const remaining = half - accumulated;
        const ratio = segment.distance > 0 ? remaining / segment.distance : 0;
        const lat = Number(segment.start.lat) + (Number(segment.end.lat) - Number(segment.start.lat)) * ratio;
        const lng = Number(segment.start.lng) + (Number(segment.end.lng) - Number(segment.start.lng)) * ratio;
        if (Number.isFinite(lat) && Number.isFinite(lng)) {
          return { lat, lng };
        }
        break;
      }
      accumulated += segment.distance;
    }

    const lastSegment = segments[segments.length - 1];
    return lastSegment ? lastSegment.end : path[path.length - 1];
  }

  function formatDistanceValue(distanceMeters) {
    if (!(distanceMeters > 0) || !Number.isFinite(distanceMeters)) {
      return '—';
    }
    if (distanceMeters >= 1000) {
      const km = distanceMeters / 1000;
      const precision = km >= 10 ? 0 : 1;
      const formattedKm = km.toLocaleString('pl-PL', {
        minimumFractionDigits: precision,
        maximumFractionDigits: precision
      });
      return `${formattedKm} km`;
    }
    const meters = Math.round(distanceMeters);
    return `${meters.toLocaleString('pl-PL')} m`;
  }

  function formatWeightValue(weight) {
    if (!(weight > 0) || !Number.isFinite(weight)) {
      return '—';
    }
    if (weight >= 0.1) {
      return weight.toLocaleString('pl-PL', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
    }
    return weight.toLocaleString('pl-PL', {
      maximumSignificantDigits: 2
    });
  }

  function buildConnectorLabelText(weight, distanceMeters) {
    const weightText = formatWeightValue(weight);
    const distanceText = formatDistanceValue(distanceMeters);
    if (weightText === '—' && distanceText === '—') {
      return '';
    }
    const parts = [];
    if (weightText !== '—') {
      parts.push(`Waga ${weightText}`);
    }
    if (distanceText !== '—') {
      parts.push(distanceText);
    }
    return parts.join(' • ');
  }

  const MAX_FALLBACK_DISTANCE_METERS = 30000;

  function computeFallbackFromNeighbors(index, baseValues, adjacencyList, dataset, graphHasPrice) {
    const baseEntry = baseValues[index] || {};
    const baseArea = Number(baseEntry.area);
    const baseDatasetEntry = Array.isArray(dataset) ? dataset[index] : null;
    const basePosition = baseDatasetEntry?.position || null;
    const directNeighbors = (adjacencyList[index] || []).filter(i => Number.isInteger(i) && i !== index);

    if (!directNeighbors.length) {
      return null;
    }

    if (!graphHasPrice) {
      return null;
    }

    const buildPriceMetrics = (value) => {
      if (!value?.hasPrice || !(value.price > 0)) {
        return null;
      }
      const sourcePrice = Number(value.price);
      const sourcePricePerSqm = Number(value.pricePerSqm);
      const sourceArea = Number(value.area);
      const normalizedPerSqm = sourcePricePerSqm > 0
        ? sourcePricePerSqm
        : (sourcePrice > 0 && Number.isFinite(sourceArea) && sourceArea > 0)
          ? sourcePrice / sourceArea
          : 0;
      return {
        price: sourcePrice > 0 ? sourcePrice : 0,
        pricePerSqm: normalizedPerSqm > 0 ? normalizedPerSqm : 0,
        area: Number.isFinite(sourceArea) && sourceArea > 0 ? sourceArea : 0
      };
    };

    const findFirstPricedFromNeighbor = (neighborIndex) => {
      if (!Number.isInteger(neighborIndex)) {
        return null;
      }

      const neighborPosition = dataset?.[neighborIndex]?.position || null;
      const initialDistance = computeDistanceBetweenPoints(basePosition, neighborPosition);
      if (!Number.isFinite(initialDistance) || initialDistance > MAX_FALLBACK_DISTANCE_METERS) {
        return null;
      }

      const initialMetrics = buildPriceMetrics(baseValues[neighborIndex]);
      if (initialMetrics) {
        return {
          sourceIndex: neighborIndex,
          path: [index, neighborIndex],
          metrics: initialMetrics,
          distance: initialDistance
        };
      }

      const guardLimit = Math.max(baseValues.length * 4, 16);
      const queue = [{ node: neighborIndex, path: [index, neighborIndex], distance: initialDistance }];
      const bestDistance = new Map([[neighborIndex, initialDistance]]);
      let guard = 0;

      while (queue.length && guard < guardLimit) {
        const current = queue.shift();
        guard += 1;

        const neighborsOfCurrent = adjacencyList[current.node] || [];
        for (const next of neighborsOfCurrent) {
          if (!Number.isInteger(next) || next === index) {
            continue;
          }
          const currentPosition = dataset?.[current.node]?.position || null;
          const nextPosition = dataset?.[next]?.position || null;
          const segmentDistance = computeDistanceBetweenPoints(currentPosition, nextPosition);
          if (!Number.isFinite(segmentDistance)) {
            continue;
          }
          const totalDistance = current.distance + segmentDistance;
          if (totalDistance > MAX_FALLBACK_DISTANCE_METERS) {
            continue;
          }

          const previousBest = bestDistance.get(next);
          if (typeof previousBest === 'number' && previousBest <= totalDistance) {
            continue;
          }
          bestDistance.set(next, totalDistance);

          const nextPath = current.path.concat(next);
          const metrics = buildPriceMetrics(baseValues[next]);
          if (metrics) {
            return {
              sourceIndex: next,
              path: nextPath,
              metrics,
              distance: totalDistance
            };
          }

          queue.push({ node: next, path: nextPath, distance: totalDistance });
        }
      }

      return null;
    };

    const contributionsByPath = new Map();

    const computeDistanceWeight = (distanceMeters) => {
      if (!(distanceMeters >= 0) || !Number.isFinite(distanceMeters)) {
        return 0;
      }

      const normalized = distanceMeters / 1000;
      return 1 / (1 + normalized);
    };

    directNeighbors.forEach(neighborIndex => {
      const contribution = findFirstPricedFromNeighbor(neighborIndex);
      if (!contribution) {
        return;
      }

      const normalizedPath = Array.isArray(contribution.path) && contribution.path.length >= 2
        ? contribution.path.slice()
        : [index, contribution.sourceIndex];
      if (normalizedPath[0] !== index) {
        normalizedPath.unshift(index);
      }
      if (normalizedPath[normalizedPath.length - 1] !== contribution.sourceIndex) {
        normalizedPath.push(contribution.sourceIndex);
      }

      const pathDistance = Number.isFinite(contribution.distance)
        ? contribution.distance
        : computePathDistance(normalizedPath, dataset);
      if (!Number.isFinite(pathDistance) || pathDistance > MAX_FALLBACK_DISTANCE_METERS) {
        return;
      }

      const pathKey = normalizedPath.join('>');
      const contributionWeight = computeDistanceWeight(pathDistance);
      if (!(contributionWeight > 0)) {
        return;
      }

      if (contributionsByPath.has(pathKey)) {
        const existing = contributionsByPath.get(pathKey);
        existing.weight += contributionWeight;
      } else {
        contributionsByPath.set(pathKey, {
          sourceIndex: contribution.sourceIndex,
          path: normalizedPath,
          metrics: contribution.metrics,
          weight: contributionWeight,
          distance: pathDistance
        });
      }
    });

    if (!contributionsByPath.size) {
      return null;
    }

    let weightedPerSqmSum = 0;
    let perSqmWeight = 0;
    let totalPrice = 0;
    let priceWeight = 0;
    let totalArea = 0;
    const fallbackSources = [];

    let contributions = Array.from(contributionsByPath.values());
    if (!contributions.length) {
      return null;
    }

    contributions.sort((a, b) => {
      const distA = Number.isFinite(a.distance) ? a.distance : Infinity;
      const distB = Number.isFinite(b.distance) ? b.distance : Infinity;
      if (distA !== distB) {
        return distA - distB;
      }
      const idxA = Number.isInteger(a.sourceIndex) ? a.sourceIndex : Infinity;
      const idxB = Number.isInteger(b.sourceIndex) ? b.sourceIndex : Infinity;
      return idxA - idxB;
    });

    const maxSources = directNeighbors.length > 0 ? directNeighbors.length : contributions.length;
    if (maxSources > 0 && contributions.length > maxSources) {
      contributions = contributions.slice(0, maxSources);
    }

    contributions.forEach(entry => {
      const { metrics, weight, sourceIndex, path, distance } = entry;
      const pricePerSqm = Number(metrics.pricePerSqm);
      const price = Number(metrics.price);
      const area = Number(metrics.area);

      if (pricePerSqm > 0) {
        weightedPerSqmSum += pricePerSqm * weight;
        perSqmWeight += weight;
      }

      if (price > 0) {
        totalPrice += price * weight;
        priceWeight += weight;
      }

      if (area > 0) {
        totalArea += area * weight;
      }

      fallbackSources.push({
        sourceIndex,
        directPath: [index, sourceIndex],
        fullPath: path,
        distanceMeters: Number.isFinite(distance) ? distance : computePathDistance(path, dataset),
        weight
      });
    });

    if (!perSqmWeight && !priceWeight) {
      return null;
    }

    const fallbackArea = Number.isFinite(baseArea) && baseArea > 0
      ? baseArea
      : (totalArea > 0 ? totalArea / (perSqmWeight || priceWeight || 1) : 0);

    let resolvedPricePerSqm = perSqmWeight > 0 ? (weightedPerSqmSum / perSqmWeight) : 0;
    if (!(resolvedPricePerSqm > 0) && totalArea > 0 && totalPrice > 0) {
      resolvedPricePerSqm = totalPrice / totalArea;
    }

    let resolvedPrice = 0;
    if (resolvedPricePerSqm > 0 && fallbackArea > 0) {
      resolvedPrice = resolvedPricePerSqm * fallbackArea;
    } else if (priceWeight > 0) {
      resolvedPrice = totalPrice / priceWeight;
      if (!(resolvedPricePerSqm > 0) && fallbackArea > 0) {
        resolvedPricePerSqm = resolvedPrice / fallbackArea;
      }
    }

    if (!(resolvedPrice > 0) && !(resolvedPricePerSqm > 0)) {
      return null;
    }

    return {
      price: resolvedPrice > 0 ? resolvedPrice : 0,
      pricePerSqm: resolvedPricePerSqm > 0 ? resolvedPricePerSqm : 0,
      sources: fallbackSources
    };
  }

  function resolveVoronoiValues(baseValues, adjacencyList, dataset) {
    const graphHasPrice = baseValues.some(value => value?.hasPrice && value.price > 0);

    return baseValues.map((entry, index) => {
      if (!entry) return entry;
      if (entry.hasPrice && entry.price > 0) {
        return {
          ...entry,
          fallbackSources: Array.isArray(entry.fallbackSources) ? entry.fallbackSources.slice() : []
        };
      }

      const fallback = computeFallbackFromNeighbors(index, baseValues, adjacencyList, dataset, graphHasPrice);
      if (!fallback) {
        return {
          ...entry,
          fallbackSources: []
        };
      }

      const normalizedSources = Array.isArray(fallback.sources)
        ? fallback.sources
            .map(source => {
              let path = Array.isArray(source?.directPath) && source.directPath.length >= 2
                ? source.directPath.slice()
                : null;
              if (!path && Array.isArray(source?.fullPath) && source.fullPath.length >= 2) {
                path = source.fullPath.slice();
              }
              const sourceIndex = Number.isInteger(source?.sourceIndex)
                ? source.sourceIndex
                : null;
              if (!path) {
                if (!Number.isInteger(sourceIndex)) {
                  return null;
                }
                path = [index, sourceIndex];
              } else if (path[0] !== index) {
                path.unshift(index);
              }
              const sanitizedPath = path
                .map(value => (Number.isInteger(value) ? value : null))
                .filter(value => Number.isInteger(value));
              if (sanitizedPath.length < 2) {
                return null;
              }
              const resolvedSourceIndex = Number.isInteger(sourceIndex)
                ? sourceIndex
                : sanitizedPath[sanitizedPath.length - 1];
              const distanceMeters = Number.isFinite(source?.distanceMeters)
                ? source.distanceMeters
                : computePathDistance(sanitizedPath, dataset);
              const weightValue = Number(source?.weight);
              return {
                path: sanitizedPath,
                sourceIndex: Number.isInteger(resolvedSourceIndex) ? resolvedSourceIndex : null,
                distanceMeters: Number.isFinite(distanceMeters) ? distanceMeters : null,
                weight: Number.isFinite(weightValue) && weightValue > 0 ? weightValue : null
              };
            })
            .filter(entry => entry && Array.isArray(entry.path) && entry.path.length >= 2)
        : [];

      return {
        ...entry,
        price: fallback.price,
        pricePerSqm: fallback.pricePerSqm,
        hasPrice: true,
        fallbackSources: normalizedSources
      };
    });
  }

  function aggregateVoronoiValues(values, index) {
    const entry = values[index];
    if (entry?.hasPrice && entry.price > 0) {
      return {
        price: entry.price,
        pricePerSqm: entry.pricePerSqm
      };
    }
    return { price: 0, pricePerSqm: 0 };
  }

  function ensureVoronoiLabelOverlay() {
    if (!map) return null;
    if (voronoiLayerState.labelLayout.overlay) {
      return voronoiLayerState.labelLayout.overlay;
    }

    try {
      const overlay = new google.maps.OverlayView();
      overlay.onAdd = () => {};
      overlay.draw = () => {};
      overlay.onRemove = () => {};
      overlay.setMap(map);
      voronoiLayerState.labelLayout.overlay = overlay;
      return overlay;
    } catch (error) {
      console.warn('Nie udało się utworzyć nakładki dla etykiet Voronoi.', error);
      return null;
    }
  }

  function resetVoronoiLabelLayout() {
    const overlay = ensureVoronoiLabelOverlay();
    voronoiLayerState.labelLayout.boxes = [];
    if (!overlay?.getProjection?.() && map && !voronoiLayerState.labelLayout.projectionPending) {
      voronoiLayerState.labelLayout.projectionPending = true;
      google.maps.event.addListenerOnce(map, 'idle', () => {
        voronoiLayerState.labelLayout.projectionPending = false;
        if (voronoiLayerState.enabled) {
          updateVoronoiLayer(true);
        }
      });
    }
  }

  function buildVoronoiLabelBox(centerPoint) {
    if (!centerPoint) return null;
    const x = Number(centerPoint.x);
    const y = Number(centerPoint.y);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;

    const halfWidth = VORONOI_LABEL_SIZE.width / 2;
    const halfHeight = VORONOI_LABEL_SIZE.height / 2;

    return {
      left: x - halfWidth,
      right: x + halfWidth,
      top: y - halfHeight,
      bottom: y + halfHeight
    };
  }

  function boxesOverlap(a, b) {
    if (!a || !b) return false;
    return !(
      a.right < b.left ||
      a.left > b.right ||
      a.bottom < b.top ||
      a.top > b.bottom
    );
  }

  function findNonOverlappingLabelPosition(position) {
    const overlay = ensureVoronoiLabelOverlay();
    const projection = overlay?.getProjection?.();
    if (!projection) {
      return position;
    }

    let basePoint;
    try {
      basePoint = projection.fromLatLngToDivPixel(position);
    } catch (error) {
      console.warn('Nie udało się przeliczyć pozycji etykiety Voronoi na piksele.', error);
      return position;
    }

    if (!basePoint) {
      return position;
    }

    const offsets = [
      { x: 0, y: 0 },
      { x: 0, y: -40 },
      { x: 0, y: 40 },
      { x: 40, y: 0 },
      { x: -40, y: 0 },
      { x: 40, y: -40 },
      { x: -40, y: -40 },
      { x: 40, y: 40 },
      { x: -40, y: 40 },
      { x: 0, y: -80 },
      { x: 0, y: 80 },
      { x: 80, y: 0 },
      { x: -80, y: 0 },
      { x: 80, y: -48 },
      { x: -80, y: -48 },
      { x: 80, y: 48 },
      { x: -80, y: 48 }
    ];

    const existingBoxes = voronoiLayerState.labelLayout.boxes;

    for (const offset of offsets) {
      const candidatePoint = {
        x: basePoint.x + offset.x,
        y: basePoint.y + offset.y
      };
      const candidateBox = buildVoronoiLabelBox(candidatePoint);
      if (!candidateBox) continue;

      const collision = existingBoxes.some(box => boxesOverlap(candidateBox, box));
      if (collision) continue;

      let latLng;
      try {
        latLng = projection.fromDivPixelToLatLng(new google.maps.Point(candidatePoint.x, candidatePoint.y));
      } catch (error) {
        console.warn('Nie udało się przeliczyć pikseli na pozycję etykiety Voronoi.', error);
        continue;
      }

      if (!latLng) continue;

      existingBoxes.push(candidateBox);
      return latLng;
    }

    const fallbackBox = buildVoronoiLabelBox(basePoint);
    if (fallbackBox) {
      existingBoxes.push(fallbackBox);
    }
    return position;
  }

  function formatPriceValue(value) {
    if (!Number.isFinite(value)) return '0';
    const rounded = Math.round(value);
    return rounded.toLocaleString('pl-PL');
  }

  function buildVoronoiLabelContent(stats, options = {}) {
    const isFallback = options.fallback === true;
    const ppm2 = `${formatPriceValue(stats.pricePerSqm)} zł/m²`;
    const priceValue = Number.isFinite(stats.price) && stats.price > 0
      ? `${formatPriceValue(stats.price)} zł`
      : null;

    const parts = [];
    if (isFallback) {
      parts.push('<span class="voronoi-label__badge" aria-hidden="true">szac.</span>');
    }
    const stackParts = [`<span class="voronoi-label__value">${ppm2}</span>`];
    if (priceValue) {
      stackParts.push(`<span class="voronoi-label__price">${priceValue}</span>`);
    }
    parts.push(`<span class="voronoi-label__stack">${stackParts.join('')}</span>`);

    const plainParts = [ppm2];
    if (priceValue) {
      plainParts.push(priceValue);
    }
    if (isFallback) {
      plainParts.push('szac.');
    }

    return {
      html: parts.join(''),
      plain: plainParts.join(' · '),
      fallback: isFallback
    };
  }

  function applyVoronoiLabelStyles(wrapper, options = {}) {
    if (!wrapper) return;

    const isFallback = options.fallback === true;
    const density = options.density === 'compact' ? 'compact' : null;

    wrapper.classList.add('voronoi-pill', 'voronoi-label');
    wrapper.setAttribute('role', 'presentation');
    wrapper.style.pointerEvents = 'none';
    if (isFallback) {
      wrapper.dataset.fallback = 'true';
    } else {
      delete wrapper.dataset.fallback;
    }
    if (density) {
      wrapper.dataset.density = density;
    } else {
      delete wrapper.dataset.density;
    }
  }

  function applyVoronoiConnectorStyles(wrapper) {
    if (!wrapper) return;
    wrapper.classList.add('voronoi-pill', 'voronoi-pill--compact', 'voronoi-connector-label');
    wrapper.setAttribute('role', 'presentation');
    wrapper.style.pointerEvents = 'none';
  }

  function calculatePolygonCentroid(path) {
    if (!Array.isArray(path) || path.length === 0) return null;
    let signedArea = 0;
    let cx = 0;
    let cy = 0;
    for (let i = 0; i < path.length; i++) {
      const current = path[i];
      const next = path[(i + 1) % path.length];
      if (!current || !next) continue;
      const x0 = current.lng;
      const y0 = current.lat;
      const x1 = next.lng;
      const y1 = next.lat;
      const a = x0 * y1 - x1 * y0;
      signedArea += a;
      cx += (x0 + x1) * a;
      cy += (y0 + y1) * a;
    }
    signedArea *= 0.5;
    if (Math.abs(signedArea) < 1e-6) {
      return path[0] || null;
    }
    cx /= (6 * signedArea);
    cy /= (6 * signedArea);
    return { lat: cy, lng: cx };
  }

  function isPointInsidePolygon(point, polygon) {
    if (!point || !Array.isArray(polygon) || polygon.length < 3) return false;
    const px = Number(point.lng);
    const py = Number(point.lat);
    if (!Number.isFinite(px) || !Number.isFinite(py)) return false;

    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const pi = polygon[i];
      const pj = polygon[j];
      const xi = Number(pi?.lng);
      const yi = Number(pi?.lat);
      const xj = Number(pj?.lng);
      const yj = Number(pj?.lat);
      if (!Number.isFinite(xi) || !Number.isFinite(yi) || !Number.isFinite(xj) || !Number.isFinite(yj)) {
        continue;
      }

      if ((yi > py) === (yj > py)) continue;
      const denominator = yj - yi;
      if (Math.abs(denominator) < 1e-12) continue;
      const xIntersect = ((xj - xi) * (py - yi)) / denominator + xi;
      if (px < xIntersect) inside = !inside;
    }

    return inside;
  }

  function getPolygonInteriorPoint(polygon, fallback) {
    if (!Array.isArray(polygon) || polygon.length < 3) {
      return fallback || null;
    }

    const cleanPolygon = polygon.filter(point => (
      point && Number.isFinite(point.lat) && Number.isFinite(point.lng)
    ));
    if (cleanPolygon.length < 3) {
      return fallback || null;
    }

    const centroid = calculatePolygonCentroid(cleanPolygon);
    if (centroid && isPointInsidePolygon(centroid, cleanPolygon)) {
      return centroid;
    }

    const sum = cleanPolygon.reduce((acc, point) => {
      acc.lat += point.lat;
      acc.lng += point.lng;
      return acc;
    }, { lat: 0, lng: 0 });
    const averagePoint = {
      lat: sum.lat / cleanPolygon.length,
      lng: sum.lng / cleanPolygon.length
    };
    if (Number.isFinite(averagePoint.lat) && Number.isFinite(averagePoint.lng) && isPointInsidePolygon(averagePoint, cleanPolygon)) {
      return averagePoint;
    }

    let minLat = cleanPolygon[0].lat;
    let maxLat = cleanPolygon[0].lat;
    let minLng = cleanPolygon[0].lng;
    let maxLng = cleanPolygon[0].lng;
    cleanPolygon.forEach(point => {
      if (point.lat < minLat) minLat = point.lat;
      if (point.lat > maxLat) maxLat = point.lat;
      if (point.lng < minLng) minLng = point.lng;
      if (point.lng > maxLng) maxLng = point.lng;
    });
    const bboxCenter = { lat: (minLat + maxLat) / 2, lng: (minLng + maxLng) / 2 };
    if (isPointInsidePolygon(bboxCenter, cleanPolygon)) {
      return bboxCenter;
    }

    for (let i = 1; i < cleanPolygon.length - 1; i++) {
      const a = cleanPolygon[0];
      const b = cleanPolygon[i];
      const c = cleanPolygon[i + 1];
      const triPoint = {
        lat: (a.lat + b.lat + c.lat) / 3,
        lng: (a.lng + b.lng + c.lng) / 3
      };
      if (isPointInsidePolygon(triPoint, cleanPolygon)) {
        return triPoint;
      }
    }

    if (fallback && Number.isFinite(fallback.lat) && Number.isFinite(fallback.lng) && isPointInsidePolygon(fallback, cleanPolygon)) {
      return fallback;
    }

    const first = cleanPolygon[0];
    const target = centroid && Number.isFinite(centroid.lat) && Number.isFinite(centroid.lng)
      ? centroid
      : (fallback || cleanPolygon[1] || first);
    if (first && target) {
      const nudged = {
        lat: first.lat + (target.lat - first.lat) * 0.25,
        lng: first.lng + (target.lng - first.lng) * 0.25
      };
      if (isPointInsidePolygon(nudged, cleanPolygon)) {
        return nudged;
      }
    }

    return first || fallback || null;
  }

  function normalizeOverlayPosition(position) {
    if (typeof google === 'undefined' || !google?.maps?.LatLng) {
      return null;
    }
    if (!position) return null;
    if (position instanceof google.maps.LatLng) {
      return position;
    }
    const lat = Number(position.lat);
    const lng = Number(position.lng);
    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      return new google.maps.LatLng(lat, lng);
    }
    return null;
  }

  let HtmlMapOverlayClass = null;

  function getHtmlMapOverlayClass() {
    const overlayCtor = (typeof google !== 'undefined' && google && google.maps && google.maps.OverlayView)
      ? google.maps.OverlayView
      : null;

    if (HtmlMapOverlayClass && overlayCtor) {
      return HtmlMapOverlayClass;
    }
    if (!overlayCtor) {
      return null;
    }

    HtmlMapOverlayClass = class extends overlayCtor {
      constructor(options = {}) {
        super();
        this.position = normalizeOverlayPosition(options.position);
        this.element = options.element || document.createElement('div');
        this.paneName = options.pane || 'floatPane';
        this.zIndex = Number.isFinite(options.zIndex) ? options.zIndex : 0;
        this.alwaysInteractive = options.pointerEvents === true;
        this.ariaLabel = typeof options.ariaLabel === 'string' ? options.ariaLabel : '';

        this.element.style.position = 'absolute';
        this.element.style.transform = 'translate(-50%, -50%)';
        if (!this.alwaysInteractive) {
          this.element.style.pointerEvents = 'none';
        }
        if (this.ariaLabel) {
          this.element.setAttribute('aria-label', this.ariaLabel);
        }

        if (options.map) {
          this.setMap(options.map);
        }
      }

      onAdd() {
        const panes = this.getPanes();
        const targetPane = panes?.[this.paneName] || panes?.floatPane || panes?.overlayMouseTarget || panes?.overlayLayer;
        if (!targetPane) return;
        if (Number.isFinite(this.zIndex)) {
          this.element.style.zIndex = String(this.zIndex);
        }
        targetPane.appendChild(this.element);
      }

      draw() {
        if (!this.element || !this.position) return;
        const projection = this.getProjection();
        if (!projection) return;
        const point = projection.fromLatLngToDivPixel(normalizeOverlayPosition(this.position));
        if (!point) return;
        this.element.style.left = `${point.x}px`;
        this.element.style.top = `${point.y}px`;
      }

      onRemove() {
        if (this.element?.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
      }

      getPosition() {
        return this.position || null;
      }

      setPosition(position) {
        const normalized = normalizeOverlayPosition(position);
        if (!normalized) return;
        this.position = normalized;
        this.draw();
      }

      setZIndex(zIndex) {
        this.zIndex = Number.isFinite(zIndex) ? zIndex : 0;
        if (this.element) {
          this.element.style.zIndex = String(this.zIndex);
        }
      }
    };

    return HtmlMapOverlayClass;
  }

  function createHtmlMapOverlay(options = {}) {
    const OverlayClass = getHtmlMapOverlayClass();
    if (!OverlayClass) {
      return null;
    }
    return new OverlayClass(options);
  }

  function createVoronoiLabelNode(htmlContent, fallbackText, position, options = {}) {
    if (!position) return null;
    const isFallback = options.fallback === true;
    const density = typeof options.density === 'string' ? options.density : 'default';
    const wrapper = document.createElement('div');
    wrapper.innerHTML = htmlContent;
    applyVoronoiLabelStyles(wrapper, { fallback: isFallback, density });

    const overlay = createHtmlMapOverlay({
      position,
      element: wrapper,
      map: voronoiLayerState.enabled ? map : null,
      zIndex: 120,
      ariaLabel: typeof fallbackText === 'string' ? fallbackText : ''
    });

    if (overlay) {
      return overlay;
    }

    return new google.maps.Marker({
      position,
      map: voronoiLayerState.enabled ? map : null,
      icon: { path: google.maps.SymbolPath.CIRCLE, scale: 0.01, strokeWeight: 0 },
      label: {
        text: fallbackText,
        color: '#111827',
        fontSize: '12px',
        fontWeight: '600'
      },
      zIndex: 120
    });
  }

  function createVoronoiConnectorLabel(text, position) {
    if (!position || typeof text !== 'string' || !text.trim()) {
      return null;
    }

    const wrapper = document.createElement('span');
    wrapper.textContent = text;
    applyVoronoiConnectorStyles(wrapper);

    const overlay = createHtmlMapOverlay({
      position,
      element: wrapper,
      map: null,
      zIndex: 150,
      ariaLabel: text
    });

    if (overlay) {
      return overlay;
    }

    return new google.maps.Marker({
      position,
      map: null,
      icon: { path: google.maps.SymbolPath.CIRCLE, scale: 0.01, strokeWeight: 0 },
      label: {
        text,
        color: '#111827',
        fontSize: '11px',
        fontWeight: '600'
      },
      zIndex: 150
    });
  }

  function clearVoronoiLayer(options = {}) {
    const {
      resetHighlight = true,
      preserveResolvedData = false,
      preserveFrozenLayout = false
    } = options || {};
    clearVoronoiHighlights({ resetSelection: resetHighlight });

    voronoiLayerState.polygons.forEach(poly => {
      if (poly && typeof poly.setMap === 'function') {
        poly.setMap(null);
      }
    });
    voronoiLayerState.polygons = [];

    voronoiLayerState.connectors.forEach(connector => {
      if (connector && typeof connector.setMap === 'function') {
        connector.setMap(null);
      }
      if (connector && typeof connector.setVisible === 'function') {
        connector.setVisible(false);
      }
      if (connector?.__voronoiLabel) {
        setOverlayMap(connector.__voronoiLabel, null);
      }
    });
    voronoiLayerState.connectors = [];

    voronoiLayerState.labels.forEach(label => {
      if (!label) return;
      if (typeof label.setMap === 'function') {
        label.setMap(null);
      } else if ('map' in label) {
        label.map = null;
      }
    });
    voronoiLayerState.labels = [];
    voronoiLayerState.labelLayout.boxes = [];
    voronoiLayerState.labelLayout.projectionPending = false;
    if (!preserveResolvedData) {
      voronoiLayerState.connectorIndexMap = new Map();
      voronoiLayerState.resolvedValues = [];
      voronoiLayerState.datasetSnapshot = [];
      voronoiLayerState.cells = [];
      voronoiLayerState.adjacencyList = [];
      voronoiLayerState.currentExtent = null;
    }
    if (!preserveFrozenLayout) {
      voronoiLayerState.frozenLayout = null;
    }

    if (voronoiLayerState.enabled) {
      refreshVoronoiIndicators();
    } else {
      clearVoronoiIndicators();
    }
  }

  function mergeVoronoiSupplementaryOffers(sourceOffers) {
    const base = Array.isArray(sourceOffers)
      ? sourceOffers.filter(Boolean).slice()
      : [];
    const supplementaryPool = (currentVoronoiSupplementary.length
      ? currentVoronoiSupplementary
      : voronoiSupplementaryOffers).filter(Boolean);
    if (!supplementaryPool.length) {
      return base;
    }

    const keyFor = (offer) => {
      if (!offer) return null;
      if (typeof offer.key === 'string') {
        return offer.key;
      }
      const rawId = offer?.id || '';
      const rawIndex = Number.isInteger(offer?.index) ? offer.index : '';
      return `${rawId}__${rawIndex}`;
    };

    const existingKeys = new Set(base.map(keyFor).filter(Boolean));

    supplementaryPool.forEach(offer => {
      const offerKey = keyFor(offer);
      if (offerKey && existingKeys.has(offerKey)) {
        return;
      }
      base.push(offer);
      if (offerKey) {
        existingKeys.add(offerKey);
      }
    });

    return base;
  }

  function getVoronoiSourceOffers() {
    const selectionLock = getActiveVoronoiSelectionLock();
    if (selectionLock) {
      const lockedOffers = Array.isArray(selectionLock.layout?.offers)
        ? selectionLock.layout.offers.filter(Boolean)
        : [];
      if (lockedOffers.length) {
        return mergeVoronoiSupplementaryOffers(lockedOffers);
      }
    }

    const freezeActive = shouldFreezeVoronoiLayout();
    if (freezeActive) {
      const frozenOffers = Array.isArray(voronoiLayerState.frozenLayout?.offers)
        ? voronoiLayerState.frozenLayout.offers.filter(Boolean)
        : [];
      if (frozenOffers.length) {
        return mergeVoronoiSupplementaryOffers(frozenOffers);
      }
      const preservedOffers = Array.isArray(voronoiLayerState.lastNonFrozenSource?.offers)
        ? voronoiLayerState.lastNonFrozenSource.offers.filter(Boolean)
        : [];
      if (preservedOffers.length) {
        return mergeVoronoiSupplementaryOffers(preservedOffers);
      }
    }
    if (currentVoronoiOffers.length || currentVoronoiSupplementary.length) {
      return mergeVoronoiSupplementaryOffers(currentVoronoiOffers);
    }
    if (allOffers.length || voronoiSupplementaryOffers.length) {
      return mergeVoronoiSupplementaryOffers(allOffers);
    }
    return [];
  }

  function getFrozenVoronoiOffers() {
    const cached = voronoiLayerState.cachedDataset;
    if (!cached || !Array.isArray(cached.dataset)) {
      return [];
    }
    return cached.dataset
      .map(entry => entry?.offer)
      .filter(Boolean);
  }

  function rebuildVoronoiLayer() {
    if (!voronoiLayerState.enabled || !map) return;
    if (!window.d3 || !window.d3.Delaunay) {
      console.warn('Biblioteka d3-delaunay jest niedostępna. Warstwa Voronoi zostanie pominięta.');
      return;
    }

    if (shouldHideVoronoiLayer()) {
      clearVoronoiLayer({ resetHighlight: false, preserveResolvedData: true, preserveFrozenLayout: true });
      return;
    }

    const selectionLock = getActiveVoronoiSelectionLock();
    const freezeActive = shouldFreezeVoronoiLayout();
    const lockActive = !!selectionLock;
    const effectiveFreeze = freezeActive || lockActive;
    if (!effectiveFreeze && voronoiLayerState.frozenLayout) {
      voronoiLayerState.frozenLayout = null;
    }

    const preservedFrozenLayout = lockActive
      ? selectionLock.layout
      : (freezeActive && voronoiLayerState.frozenLayout
          ? voronoiLayerState.frozenLayout
          : null);
    const frozenLayout = preservedFrozenLayout
      ? {
          offers: Array.isArray(preservedFrozenLayout.offers)
            ? preservedFrozenLayout.offers.slice()
            : [],
          signature: typeof preservedFrozenLayout.signature === 'string'
            ? preservedFrozenLayout.signature
            : null,
          cache: cloneVoronoiCache(
            preservedFrozenLayout.dataset,
            preservedFrozenLayout.adjacencyList,
            preservedFrozenLayout.resolvedValues,
            preservedFrozenLayout.extent,
            preservedFrozenLayout.cells
          )
        }
      : null;

    const hasFrozenCache = !frozenLayout && effectiveFreeze
      && Array.isArray(voronoiLayerState.cachedDataset?.dataset)
      && voronoiLayerState.cachedDataset.dataset.length;

    let usingFrozenLayout = !!frozenLayout;
    let usingFrozenCache = false;
    let usedFullFilteredOffers = false;

    const preservedSource = voronoiLayerState.lastNonFrozenSource || {};
    const preservedOffers = Array.isArray(preservedSource.offers)
      ? preservedSource.offers.filter(Boolean)
      : [];
    const preservedSignature = typeof preservedSource.signature === 'string'
      ? preservedSource.signature
      : null;
    const preservedExtent = Array.isArray(preservedSource.extent) && preservedSource.extent.length === 4
      ? preservedSource.extent.slice()
      : null;
    let usingPreservedSource = false;

    let offers;
    if (usingFrozenLayout) {
      offers = frozenLayout.offers.slice();
    } else if (hasFrozenCache) {
      offers = getFrozenVoronoiOffers();
      usingFrozenCache = true;
    } else if (freezeActive) {
      if (preservedOffers.length) {
        offers = preservedOffers.slice();
        usingPreservedSource = true;
      } else {
        offers = getVoronoiSourceOffers();
        if (!offers.length) {
          offers = getOffersMatchingFilters();
          if (offers.length) {
            usedFullFilteredOffers = true;
          }
        }
      }
    } else {
      offers = getVoronoiSourceOffers();
    }

    const offersForSignature = Array.isArray(offers) ? offers : [];
    const computedSignature = offersForSignature
      .map(offer => (offer?.key || offer?.id || ''))
      .join('|');
    const sourceSignature = usingFrozenLayout && frozenLayout?.signature
      ? frozenLayout.signature
      : usingFrozenCache && voronoiLayerState.cacheSignature
        ? voronoiLayerState.cacheSignature
        : usingPreservedSource && preservedSignature
          ? preservedSignature
          : computedSignature;

    let normalizedOffers;
    if (usingFrozenLayout && Array.isArray(frozenLayout?.cache?.dataset)) {
      normalizedOffers = frozenLayout.cache.dataset
        .map(entry => entry?.offer)
        .filter(Boolean);
    } else {
      normalizedOffers = Array.isArray(offers)
        ? offers.filter(Boolean)
        : [];
    }
    const cached = usingFrozenLayout
      ? frozenLayout?.cache
      : usingFrozenCache
        ? voronoiLayerState.cachedDataset
        : (freezeActive && voronoiLayerState.cacheSignature === sourceSignature)
          ? voronoiLayerState.cachedDataset
          : null;
    const cachedCells = Array.isArray(cached?.cells) && cached.cells.length
      ? cached.cells.map(cell => cloneVoronoiCell(cell))
      : null;

    let dataset = [];
    let adjacencyList = [];
    let resolvedValues = [];
    let extent = null;
    let delaunay;
    let voronoi;
    let shouldUpdateCache = false;

    if (cached && Array.isArray(cached.dataset) && cached.dataset.length) {
      dataset = cached.dataset;
      adjacencyList = Array.isArray(cached.adjacencyList) ? cached.adjacencyList : [];
      resolvedValues = Array.isArray(cached.resolvedValues) ? cached.resolvedValues : [];
      extent = Array.isArray(cached.extent) ? cached.extent.slice() : null;
      if (!Array.isArray(extent) || extent.length !== 4) {
        const bounds = map.getBounds();
        if (bounds) {
          const sw = bounds.getSouthWest();
          const ne = bounds.getNorthEast();
          extent = [sw.lng(), sw.lat(), ne.lng(), ne.lat()];
        }
      }
      if (!cachedCells) {
        try {
          const points = dataset.map(({ position }) => [position.lng, position.lat]);
          delaunay = window.d3.Delaunay.from(points);
          voronoi = delaunay.voronoi(extent);
        } catch (error) {
          console.warn('Nie udało się zbudować zamrożonego diagramu Voronoi.', error);
          return;
        }
      }
    } else {
      dataset = normalizedOffers
        .map(offer => {
          const source = offer?.voronoiPoint || null;
          let lat = Number(source?.lat);
          let lng = Number(source?.lng);

          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            lat = Number(offer?.plot?.lat);
            lng = Number(offer?.plot?.lng);
          }

          if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;

          return { offer, position: { lat, lng } };
        })
        .filter(Boolean);

      if (!dataset.length) {
        clearVoronoiLayer();
        voronoiLayerState.cachedDataset = null;
        voronoiLayerState.cacheSignature = null;
        voronoiLayerState.frozenLayout = null;
        voronoiLayerState.lastNonFrozenSource = {
          offers: [],
          signature: null,
          extent: null
        };
        return;
      }

      if (freezeActive && usingPreservedSource && preservedExtent) {
        extent = preservedExtent.slice();
      } else {
        const bounds = map.getBounds();
        if (!bounds) return;

        const sw = bounds.getSouthWest();
        const ne = bounds.getNorthEast();
        extent = [sw.lng(), sw.lat(), ne.lng(), ne.lat()];
      }

      try {
        const points = dataset.map(({ position }) => [position.lng, position.lat]);
        delaunay = window.d3.Delaunay.from(points);
      } catch (error) {
        console.warn('Nie udało się zbudować diagramu Voronoi.', error);
        return;
      }

      try {
        voronoi = delaunay.voronoi(extent);
      } catch (error) {
        console.warn('Nie udało się utworzyć diagramu Voronoi dla bieżącego widoku.', error);
        return;
      }
      adjacencyList = dataset.map((_, index) => {
        const iterator = delaunay.neighbors(index);
        if (!iterator) return [];
        const neighbors = [];
        for (const neighbor of iterator) {
          if (Number.isInteger(neighbor)) {
            neighbors.push(neighbor);
          }
        }
        return neighbors;
      });
      const baseValues = dataset.map(({ offer }) => computeOfferValueWithTags(offer));
      resolvedValues = resolveVoronoiValues(baseValues, adjacencyList, dataset);
      shouldUpdateCache = true;
    }

    if ((!normalizedOffers || !normalizedOffers.length) && Array.isArray(dataset)) {
      normalizedOffers = dataset.map(entry => entry?.offer).filter(Boolean);
    }

    let cells = Array.isArray(cachedCells) ? cachedCells : [];
    if (!cells.length) {
      if (!voronoi) {
        try {
          const points = dataset.map(({ position }) => [position.lng, position.lat]);
          delaunay = window.d3.Delaunay.from(points);
          voronoi = delaunay.voronoi(extent);
        } catch (error) {
          console.warn('Nie udało się odtworzyć diagramu Voronoi z pamięci podręcznej.', error);
          return;
        }
      }
      cells = dataset.map(({ position }, index) => {
        if (!voronoi) return null;
        const polygonCoords = voronoi.cellPolygon(index);
        if (!Array.isArray(polygonCoords) || polygonCoords.length < 3) return null;
        const path = polygonCoords.map(([lng, lat]) => ({ lat, lng }));
        const centroid = calculatePolygonCentroid(path) || position;
        return { path, centroid, position };
      });
    }

    const extentSnapshot = Array.isArray(extent) ? extent.slice() : null;
    const hasOffersToStore = normalizedOffers.length > 0;

    voronoiLayerState.currentExtent = extentSnapshot;
    voronoiLayerState.adjacencyList = Array.isArray(adjacencyList)
      ? adjacencyList.map(neighbors => Array.isArray(neighbors) ? neighbors.slice() : [])
      : [];

    if (!effectiveFreeze) {
      voronoiLayerState.lastNonFrozenSource = {
        offers: hasOffersToStore ? normalizedOffers.slice() : [],
        signature: hasOffersToStore ? sourceSignature : null,
        extent: hasOffersToStore ? extentSnapshot : null
      };
    } else if (!usingFrozenLayout && usingPreservedSource && hasOffersToStore) {
      const signature = preservedSignature || sourceSignature || null;
      const nextExtent = preservedExtent && preservedExtent.length === 4
        ? preservedExtent.slice()
        : extentSnapshot;
      voronoiLayerState.lastNonFrozenSource = {
        offers: normalizedOffers.slice(),
        signature,
        extent: nextExtent
      };
    }

    const allowCacheRefresh = !effectiveFreeze || usedFullFilteredOffers || !voronoiLayerState.cachedDataset;
    if (!usingFrozenLayout && shouldUpdateCache && allowCacheRefresh) {
      voronoiLayerState.cachedDataset = cloneVoronoiCache(dataset, adjacencyList, resolvedValues, extent, cells);
      voronoiLayerState.cacheSignature = sourceSignature;
    }

    if (freezeActive) {
      if (!usingFrozenLayout) {
        voronoiLayerState.frozenLayout = cloneFrozenVoronoiLayout(
          dataset,
          adjacencyList,
          resolvedValues,
          extent,
          normalizedOffers,
          sourceSignature,
          cells
        );
      } else if (
        preservedFrozenLayout
        && typeof sourceSignature === 'string'
        && preservedFrozenLayout.signature !== sourceSignature
      ) {
        voronoiLayerState.frozenLayout = {
          ...preservedFrozenLayout,
          signature: sourceSignature
        };
      }
    }

    const preservedSelectionKey = voronoiLayerState.highlight.selectedOfferKey;
    const preservedIndexHint = voronoiLayerState.highlight.selectedIndexHint;
    clearVoronoiLayer({ resetHighlight: false, preserveFrozenLayout: true });
    resetVoronoiLabelLayout();

    const shouldRenderLabels = shouldRenderVoronoiLabelsForDatasetSize(dataset.length);
    const labelDensity = determineVoronoiLabelDensity(dataset.length);

    voronoiLayerState.resolvedValues = resolvedValues;
    voronoiLayerState.datasetSnapshot = dataset;
    voronoiLayerState.cells = cells;
    voronoiLayerState.connectorIndexMap = new Map();

    cells.forEach((cell, index) => {
      if (!cell) return;
      let stats = aggregateVoronoiValues(resolvedValues, index);
      const resolvedEntry = resolvedValues[index];
      const resolvedPricePerSqm = Number(resolvedEntry?.pricePerSqm);
      const resolvedPriceValue = Number(resolvedEntry?.price);
      const hasFallbackSources = Array.isArray(resolvedEntry?.fallbackSources) && resolvedEntry.fallbackSources.length > 0;
      const hasAssignedValuation = hasFallbackSources;

      if (
        (!stats || stats.pricePerSqm <= 0 || stats.price <= 0)
        && resolvedEntry
        && ((Number.isFinite(resolvedPricePerSqm) && resolvedPricePerSqm > 0) || (Number.isFinite(resolvedPriceValue) && resolvedPriceValue > 0))
      ) {
        stats = {
          price: Number.isFinite(resolvedPriceValue) && resolvedPriceValue > 0 ? resolvedPriceValue : 0,
          pricePerSqm: Number.isFinite(resolvedPricePerSqm) && resolvedPricePerSqm > 0 ? resolvedPricePerSqm : 0
        };
      }

      if (!stats) {
        stats = { price: 0, pricePerSqm: 0 };
      }
      const fallbackSources = Array.isArray(resolvedEntry?.fallbackSources)
        ? resolvedEntry.fallbackSources
        : [];
      const isFallback = hasFallbackSources;
      const content = buildVoronoiLabelContent(stats, { fallback: isFallback });
      const baseMode = hasAssignedValuation ? 'baseHighlight' : 'default';

      const polygon = new google.maps.Polygon({
        paths: cell.path,
        map: voronoiLayerState.enabled ? map : null,
        ...getVoronoiPolygonStyle(baseMode),
        clickable: hasAssignedValuation,
        zIndex: 40
      });
      polygon.__voronoiIndex = index;
      polygon.__voronoiLabel = null;
      polygon.__voronoiIsAssigned = hasAssignedValuation;
      polygon.__voronoiBaseMode = baseMode;
      if (hasAssignedValuation) {
        polygon.addListener('click', () => {
          if (!voronoiLayerState.enabled) return;
          const highlightState = voronoiLayerState.highlight;
          const isAlreadySelected = highlightState.baseIndex === index;
          highlightState.ignoreNextMapClear = true;
          if (isAlreadySelected) {
            clearVoronoiHighlights({ resetSelection: true });
          } else {
            highlightVoronoiPolygon(index);
          }
          window.setTimeout(() => {
            highlightState.ignoreNextMapClear = false;
          }, 0);
        });
      }
      voronoiLayerState.polygons.push(polygon);

      if (!voronoiLayerState.connectorIndexMap.has(index)) {
        voronoiLayerState.connectorIndexMap.set(index, []);
      }

      if (shouldRenderLabels) {
        const labelPosition = findNonOverlappingLabelPosition(cell.centroid || cell.position);
        const label = createVoronoiLabelNode(content.html, content.plain, labelPosition, {
          fallback: isFallback,
          density: labelDensity
        });
        if (label) {
          polygon.__voronoiLabel = label;
          voronoiLayerState.labels.push(label);
        }
      }

      fallbackSources.forEach(source => {
        const pathIndices = Array.isArray(source?.path) ? source.path.slice() : [];
        let connectorPath = pathIndices
          .map(i => {
            const datasetEntry = dataset[i];
            const markerPosition = getMarkerPositionForDatasetEntry(datasetEntry);
            if (markerPosition) return markerPosition;
            const targetCell = cells[i];
            if (targetCell?.centroid) return targetCell.centroid;
            return datasetEntry?.position || null;
          })
          .filter(point => point && Number.isFinite(point.lat) && Number.isFinite(point.lng));

        if (connectorPath.length < 2) {
          const basePosition = getMarkerPositionForDatasetEntry(dataset[index]);
          const fallbackSourceIndex = pathIndices.length ? pathIndices[pathIndices.length - 1] : null;
          const resolvedSourceIndex = Number.isInteger(source?.sourceIndex)
            ? source.sourceIndex
            : fallbackSourceIndex;
          const sourcePosition = Number.isInteger(resolvedSourceIndex)
            ? getMarkerPositionForDatasetEntry(dataset[resolvedSourceIndex])
            : null;
          connectorPath = [basePosition, sourcePosition]
            .filter(point => point && Number.isFinite(point.lat) && Number.isFinite(point.lng));
        }

        if (connectorPath.length < 2) return;

        const connector = new google.maps.Polyline({
          path: connectorPath,
          map: null,
          clickable: false,
          visible: false,
          ...buildVoronoiConnectorStyle('default')
        });
        const resolvedSourceIndex = Number.isInteger(source?.sourceIndex)
          ? source.sourceIndex
          : (pathIndices.length ? pathIndices[pathIndices.length - 1] : null);
        connector.__voronoiBaseIndex = index;
        connector.__voronoiSourceIndex = Number.isInteger(resolvedSourceIndex) ? resolvedSourceIndex : null;
        connector.__voronoiWeight = Number.isFinite(source?.weight) ? source.weight : null;
        connector.__voronoiDistance = Number.isFinite(source?.distanceMeters) ? source.distanceMeters : null;

        const labelText = buildConnectorLabelText(connector.__voronoiWeight, connector.__voronoiDistance);
        if (labelText) {
          const midpoint = computeConnectorMidpoint(connectorPath);
          const label = createVoronoiConnectorLabel(labelText, midpoint);
          if (label) {
            connector.__voronoiLabel = label;
          }
        }

        voronoiLayerState.connectors.push(connector);
        const connectorsForBase = voronoiLayerState.connectorIndexMap.get(index) || [];
        connectorsForBase.push(connector);
        voronoiLayerState.connectorIndexMap.set(index, connectorsForBase);
      });
    });

    applyVoronoiBaseVisibility();

    if (preservedSelectionKey || Number.isInteger(preservedIndexHint)) {
      let rehighlightIndex = -1;
      if (preservedSelectionKey) {
        rehighlightIndex = voronoiLayerState.datasetSnapshot.findIndex(entry => {
          const entryKey = getVoronoiDatasetOfferKey(entry);
          return entryKey && entryKey === preservedSelectionKey;
        });
      }
      if (rehighlightIndex < 0 && Number.isInteger(preservedIndexHint)) {
        if (preservedIndexHint >= 0 && preservedIndexHint < voronoiLayerState.datasetSnapshot.length) {
          rehighlightIndex = preservedIndexHint;
        }
      }
      if (rehighlightIndex >= 0) {
        const polygon = voronoiLayerState.polygons[rehighlightIndex];
        if (polygon && polygon.__voronoiIsAssigned) {
          highlightVoronoiPolygon(rehighlightIndex);
        } else {
          voronoiLayerState.highlight.selectedOfferKey = null;
          voronoiLayerState.highlight.selectedIndexHint = null;
          hideVoronoiTagInspector();
        }
      } else {
        voronoiLayerState.highlight.selectedOfferKey = null;
        voronoiLayerState.highlight.selectedIndexHint = null;
        hideVoronoiTagInspector();
      }
    }
  }

  function updateVoronoiLayer(forceRebuild = false) {
    if (!voronoiLayerState.enabled) {
      clearVoronoiLayer();
      return;
    }
    if (forceRebuild || !voronoiLayerState.polygons.length) {
      rebuildVoronoiLayer();
    }
  }

  function offerMatchesSelectedTags(offer) {
    if (!filterState.selectedTags.size) return true;
    if (!offer.tags || !offer.tags.length) return false;
    for (const tag of filterState.selectedTags) {
      if (!offer.tags.includes(tag)) return false;
    }
    return true;
  }

  function getOffersMatchingFilters() {
    return allOffers.filter(offerMatchesSelectedTags);
  }

  function sortOffers(offers) {
    const { sortKey, sortDir } = filterState;
    if (!sortKey) return offers.slice();

    const dir = sortDir === 'desc' ? -1 : 1;
    const valueFor = (offer) => {
      if (sortKey === 'price') {
        const value = Number(offer.plot?.price);
        return Number.isFinite(value) ? value : null;
      }
      if (sortKey === 'area') {
        const value = Number(offer.plot?.pow_dzialki_m2_uldk);
        return Number.isFinite(value) ? value : null;
      }
      return null;
    };

    return offers.slice().sort((a, b) => {
      const aVal = valueFor(a);
      const bVal = valueFor(b);

      if (aVal === null && bVal === null) return 0;
      if (aVal === null) return 1;
      if (bVal === null) return -1;
      if (aVal === bVal) return 0;
      return aVal > bVal ? dir : -dir;
    });
  }

  function rebuildCluster(activeMarkers) {
    if (!map) return;
    if (markerCluster) {
      markerCluster.clearMarkers();
    }
    markerCluster = new markerClusterer.MarkerClusterer({
      map,
      markers: activeMarkers,
      renderer: clusterRenderer
    });
  }

  function updateMarkersForOffers(filteredOffers) {
    const activeKeys = new Set(filteredOffers.map(o => o.key));
    const activeMarkers = [];
    allOffers.forEach(offer => {
      const isActive = activeKeys.has(offer.key);
      if (offer.marker) {
        offer.marker.setVisible(isActive);
        offer.marker.setMap(isActive ? map : null);
        if (isActive) {
          activeMarkers.push(offer.marker);
        }
      }
    });
    rebuildCluster(activeMarkers);
  }

  function updatePolygonVisibility(filteredOffers = null) {
    if (!map) return;
    const show = map.getZoom() >= 8;
    const source = filteredOffers ?? getOffersMatchingFilters();
    const activeKeys = new Set(source.map(o => o.key));
    allOffers.forEach(offer => {
      if (!offer.polygon) return;
      const shouldShow = show && activeKeys.has(offer.key);
      offer.polygon.setMap(shouldShow ? map : null);
      offer.polygon.setVisible(!!shouldShow);
    });
  }

  function updateSortButtonsUI() {
    sortButtons.forEach(btn => {
      const key = btn.dataset.sortKey;
      const isActive = filterState.sortKey === key;
      btn.dataset.active = isActive ? 'true' : 'false';
      if (isActive) {
        btn.dataset.direction = filterState.sortDir;
        btn.setAttribute('aria-pressed', 'true');
      } else {
        btn.removeAttribute('data-direction');
        btn.setAttribute('aria-pressed', 'false');
      }
    });
  }

  function createTagChip(tag) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tag-chip';
    btn.dataset.tag = tag;
    btn.addEventListener('click', () => toggleTagFilter(tag));
    return btn;
  }

  function formatTagCount(count) {
    if (!Number.isFinite(count)) return '';
    if (count === 1) return '1 oferta';
    const mod10 = count % 10;
    const mod100 = count % 100;
    if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
      return `${count} oferty`;
    }
    return `${count} ofert`;
  }

  function pickRandomTags(source, count) {
    const pool = Array.isArray(source) ? source.slice() : [];
    for (let i = pool.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, Math.min(count, pool.length));
  }

  function ensureRandomPreviewTags() {
    const signature = availableTags.join('|');
    if (signature !== randomPreviewSignature) {
      randomPreviewSignature = signature;
      randomPreviewTags = pickRandomTags(availableTags, TAG_PREVIEW_COUNT);
    } else {
      randomPreviewTags = randomPreviewTags.filter(tag => availableTags.includes(tag));
      const missing = Math.min(TAG_PREVIEW_COUNT, availableTags.length) - randomPreviewTags.length;
      if (missing > 0) {
        const pool = availableTags.filter(tag => !randomPreviewTags.includes(tag));
        randomPreviewTags = randomPreviewTags.concat(pickRandomTags(pool, missing));
      }
    }
    return randomPreviewTags.slice(0, Math.min(TAG_PREVIEW_COUNT, availableTags.length));
  }

  function formatTagLabel(tag) {
    if (typeof tag !== 'string') return '';
    return tag.startsWith('#') ? tag : `#${tag}`;
  }

  function updateTagCollectionsForVisibleOffers(visibleOffers) {
    currentVisibleOffers = Array.isArray(visibleOffers) ? visibleOffers.slice() : [];

    const metrics = new Map();

    currentVisibleOffers.forEach(offer => {
      const offerTags = Array.isArray(offer.tags) ? offer.tags : [];
      offerTags.forEach(tag => {
        metrics.set(tag, (metrics.get(tag) || 0) + 1);
      });
    });

    filterState.selectedTags.forEach(tag => {
      if (!metrics.has(tag)) {
        metrics.set(tag, 0);
      }
    });

    tagMetrics = metrics;

    const sortedTags = Array.from(metrics.entries())
      .sort((a, b) => {
        if (b[1] !== a[1]) {
          return b[1] - a[1];
        }
        return a[0].localeCompare(b[0], 'pl', { sensitivity: 'base' });
      })
      .map(([tag]) => tag);

    const previousSignature = availableTags.join('|');
    availableTags = sortedTags;

    if (availableTags.join('|') !== previousSignature) {
      randomPreviewSignature = '';
      randomPreviewTags = [];
    }

    renderTagFilters();
  }

  function computeTagDisplayCounts(filteredOffers) {
    const counts = new Map();

    if (!filterState.selectedTags.size) {
      availableTags.forEach(tag => {
        const total = Number(tagMetrics.get(tag)) || 0;
        counts.set(tag, total);
      });
      return counts;
    }

    const matches = Array.isArray(filteredOffers) ? filteredOffers : getOffersMatchingFilters();
    const matchCount = matches.length;

    filterState.selectedTags.forEach(tag => counts.set(tag, matchCount));

    matches.forEach(offer => {
      const offerTags = Array.isArray(offer.tags) ? offer.tags : [];
      offerTags.forEach(tag => {
        if (filterState.selectedTags.has(tag)) return;
        counts.set(tag, (counts.get(tag) || 0) + 1);
      });
    });

    availableTags.forEach(tag => {
      if (!counts.has(tag)) counts.set(tag, 0);
    });

    return counts;
  }

  function configureTagChip(chip, tag, displayCounts = null) {
    const isActive = filterState.selectedTags.has(tag);
    chip.classList.toggle('is-active', isActive);
    chip.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    chip.dataset.tag = tag;
    chip.innerHTML = '';

    const labelSpan = document.createElement('span');
    labelSpan.className = 'tag-chip__label';
    const formattedLabel = formatTagLabel(tag);
    labelSpan.textContent = formattedLabel;
    chip.appendChild(labelSpan);

    const countValue = displayCounts?.get(tag);
    const numericCount = Number.isFinite(countValue) ? countValue : (Number(tagMetrics.get(tag)) || 0);

    if (Number.isFinite(numericCount)) {
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-chip__count';
      countSpan.textContent = `(${numericCount})`;
      chip.appendChild(countSpan);
    }

    const compatibleCount = Number.isFinite(countValue) ? countValue : 0;
    const isCompatible = filterState.selectedTags.size > 0 && !isActive && compatibleCount > 0;
    chip.classList.toggle('is-compatible', isCompatible);
    if (isCompatible) {
      chip.dataset.compatible = 'true';
    } else {
      chip.removeAttribute('data-compatible');
    }

    let tooltip = formattedLabel;
    if (Number.isFinite(numericCount)) {
      tooltip += ` • ${formatTagCount(numericCount)}`;
    }
    if (isCompatible) {
      const suffix = compatibleCount === 1 ? 'ofercie' : 'ofertach';
      tooltip += ` • razem z wybranymi w ${compatibleCount} ${suffix}`;
    }
    chip.title = tooltip;
  }

  function renderTagFilters() {
    if (!tagFiltersList) return;

    tagFiltersList.innerHTML = '';
    tagFiltersList.classList.remove('is-empty');

    if (!availableTags.length) {
      const placeholder = document.createElement('span');
      placeholder.className = 'tag-placeholder';
      placeholder.textContent = 'Brak tagów w ofertach';
      tagFiltersList.appendChild(placeholder);
      tagFiltersList.dataset.expanded = 'false';
      tagFiltersList.dataset.state = 'empty';
      tagFiltersList.classList.add('is-empty');
      if (toggleTagsBtn) {
        toggleTagsBtn.hidden = true;
        toggleTagsBtn.setAttribute('aria-expanded', 'false');
        toggleTagsBtn.dataset.state = 'empty';
      }
      return;
    }

    const selectedTags = Array.from(filterState.selectedTags);
    const filteredForCounts = currentVisibleOffers.length ? currentVisibleOffers : getOffersMatchingFilters();
    const displayCounts = computeTagDisplayCounts(filteredForCounts);

    const visibleTags = tagsExpanded ? availableTags.slice() : ensureRandomPreviewTags().slice();
    const visibleSet = new Set(visibleTags);

    selectedTags.forEach(tag => {
      if (!visibleSet.has(tag)) {
        visibleSet.add(tag);
        visibleTags.push(tag);
      }
    });

    const listWrap = document.createElement('div');
    listWrap.className = 'tags-preview';
    if (tagsExpanded) {
      listWrap.dataset.mode = 'expanded';
    }
    tagFiltersList.appendChild(listWrap);

    visibleTags.forEach(tag => {
      const chip = createTagChip(tag);
      configureTagChip(chip, tag, displayCounts);
      listWrap.appendChild(chip);
    });

    const hiddenCount = Math.max(availableTags.length - visibleSet.size, 0);

    if (!tagsExpanded && hiddenCount > 0) {
      const summary = document.createElement('span');
      summary.className = 'tags-summary';
      summary.textContent = `+${hiddenCount} więcej`;
      listWrap.appendChild(summary);
    }

    const shouldShowToggle = availableTags.length > TAG_PREVIEW_COUNT;
    if (!shouldShowToggle) {
      tagsExpanded = false;
    }

    if (toggleTagsBtn) {
      if (shouldShowToggle) {
        toggleTagsBtn.hidden = false;
        toggleTagsBtn.textContent = tagsExpanded ? 'Ukryj tagi' : 'Pokaż wszystkie tagi';
        toggleTagsBtn.setAttribute('aria-expanded', tagsExpanded ? 'true' : 'false');
        toggleTagsBtn.dataset.state = tagsExpanded ? 'expanded' : 'collapsed';
      } else {
        toggleTagsBtn.hidden = true;
        toggleTagsBtn.setAttribute('aria-expanded', 'false');
        toggleTagsBtn.dataset.state = 'all-visible';
      }
    }

    tagFiltersList.dataset.expanded = tagsExpanded ? 'true' : 'false';
    tagFiltersList.dataset.state = shouldShowToggle ? (tagsExpanded ? 'expanded' : 'collapsed') : 'all-visible';
  }

  function toggleTagFilter(tag) {
    if (!tag) return;
    if (filterState.selectedTags.has(tag)) {
      filterState.selectedTags.delete(tag);
    } else {
      filterState.selectedTags.add(tag);
    }
    renderTagFilters();
    applyFilters();
  }

  function applyFilters() {
    const filtered = getOffersMatchingFilters();
    updateMarkersForOffers(filtered);
    filterOffersByBounds(filtered);
    updatePolygonVisibility(filtered);
  }

  function openInfo(anchorOrPosition, html, options = {}) {
    if (!window.infoWin) window.infoWin = new google.maps.InfoWindow();
    const infoWin = window.infoWin;

    infoWin.close();
    infoWin.setContent(html);

    if (!options?.skipMapStateUpdate) {
      const hasOfferKey = Object.prototype.hasOwnProperty.call(options, 'offerId');
      const hasPlotKey = Object.prototype.hasOwnProperty.call(options, 'plotIndex');
      const offerId = hasOfferKey && typeof options.offerId === 'string' && options.offerId.trim()
        ? options.offerId.trim()
        : null;
      const plotIndex = hasPlotKey && Number.isInteger(options.plotIndex)
        ? options.plotIndex
        : null;
      const hasValidOffer = Boolean(offerId);
      const hasValidPlotIndex = plotIndex !== null;

      if (hasValidOffer || hasValidPlotIndex) {
        saveMapState({
          focusOfferId: offerId,
          focusPlotIndex: plotIndex
        });
      } else if (hasOfferKey || hasPlotKey) {
        saveMapState({ focusOfferId: null, focusPlotIndex: null });
      }
    }

    if (!map) return;

    if (anchorOrPosition && typeof anchorOrPosition.getPosition === 'function') {
      infoWin.open({ map, anchor: anchorOrPosition });
      return;
    }

    let position = null;
    if (anchorOrPosition) {
      if (typeof anchorOrPosition.lat === 'function' && typeof anchorOrPosition.lng === 'function') {
        position = anchorOrPosition;
      } else if (typeof anchorOrPosition.lat === 'number' && typeof anchorOrPosition.lng === 'number') {
        position = anchorOrPosition;
      }
    }

    if (position) {
      infoWin.setPosition(position);
    }

    infoWin.open({ map });
  }

  function panMapTo(position, minZoom = 16) {
    if (!map || !position) return;

    const target = position;
    map.panTo(target);

    if (typeof minZoom === 'number') {
      const currentZoom = map.getZoom();
      if (typeof currentZoom !== 'number' || currentZoom < minZoom) {
        map.setZoom(minZoom);
      }
    }
  }

  // ====== MAPA ======
  async function initMap() {
    hideMapsKeyPrompt();

    const mobileMediaQuery = typeof window !== 'undefined' && window.matchMedia
      ? window.matchMedia('(max-width: 768px)')
      : null;
    const isMobileScreen = mobileMediaQuery
      ? mobileMediaQuery.matches
      : (typeof window !== 'undefined' ? window.innerWidth <= 768 : false);

    map = new google.maps.Map(document.getElementById("map"), {
      center: { lat: 52.0, lng: 19.0 },
      zoom: 6,
      gestureHandling: "greedy",
      scrollwheel: true,
      mapTypeId: google.maps.MapTypeId.HYBRID,
      tilt: 0,
      heading: 0,
      tiltControl: false,
      rotateControl: false,
      streetViewControl: !isMobileScreen
    });

    const updateStreetViewControl = (isMobile) => {
      if (!map) return;
      map.setOptions({ streetViewControl: !isMobile });
    };

    if (mobileMediaQuery && typeof mobileMediaQuery.addEventListener === 'function') {
      mobileMediaQuery.addEventListener('change', (event) => updateStreetViewControl(event.matches));
    } else if (mobileMediaQuery && typeof mobileMediaQuery.addListener === 'function') {
      mobileMediaQuery.addListener((event) => updateStreetViewControl(event.matches));
    }

    const keepMapFlat = () => {
      if (!map) return;
      if (map.getTilt && map.getTilt() !== 0) {
        map.setTilt(0);
      }
      if (map.getHeading && map.getHeading() !== 0) {
        map.setHeading(0);
      }
    };

    keepMapFlat();
    ensureVoronoiLabelOverlay();

    applySavedMapView();

    if (map?.addListener) {
      map.addListener("tilt_changed", keepMapFlat);
      map.addListener("heading_changed", keepMapFlat);
    }

    google.maps.event.addListener(map, "idle", () => {
      keepMapFlat();
      filterOffersByBounds();
    });
    google.maps.event.addListener(map, "zoom_changed", () => {
      keepMapFlat();
      updatePolygonVisibility();
    });
    google.maps.event.addListener(map, "click", () => {
      if (voronoiLayerState.highlight.ignoreNextMapClear) {
        voronoiLayerState.highlight.ignoreNextMapClear = false;
        return;
      }
      clearVoronoiHighlights({ resetSelection: true });
    });
    await loadOffers();
    focusOfferFromMapState();

  }

  async function loadOffers(options = {}) {
    const { forceRefresh = false } = options || {};
    const settings = resolveOffersCacheSettings();

    const cached = readOffersCache(settings);
    if (cached && Array.isArray(cached.documents) && cached.documents.length) {
      hydrateOffersFromDocuments(cached.documents);
      if (!shouldRefreshOffersCache(cached, settings, { forceRefresh })) {
        return;
      }
    } else if (!shouldRefreshOffersCache(cached, settings, { forceRefresh: true })) {
      // brak cache, ale warunek odświeżenia i tak powinien wymusić pobranie
      // ta gałąź pozostawiona tylko dla czytelności
    }

    try {
      await refreshOffersFromSource(settings, { cachedPayload: cached });
    } catch (err) {
      console.error("Błąd pobierania ofert:", err);
      const fallback = readOffersCache(settings, { allowExpired: true });
      if (fallback && Array.isArray(fallback.documents) && !allOffers.length) {
        hydrateOffersFromDocuments(fallback.documents);
      }
    }
  }

  window.loadOffers = loadOffers;

  // widoczność listy wg granic + sortowanie wyników
  function filterOffersByBounds(filteredOffers = null) {
    if (!map || !allOffers.length) return;
    const bounds = map.getBounds();
    if (!bounds) return;

    const base = Array.isArray(filteredOffers) ? filteredOffers : getOffersMatchingFilters();
    const filteredKeys = new Set(base.map(o => o?.key));

    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    const latMin = Math.min(sw.lat(), ne.lat());
    const latMax = Math.max(sw.lat(), ne.lat());
    const lngMin = Math.min(sw.lng(), ne.lng());
    const lngMax = Math.max(sw.lng(), ne.lng());
    const withinBounds = (lat, lng) => Number.isFinite(lat)
      && Number.isFinite(lng)
      && lat >= latMin && lat <= latMax
      && lng >= lngMin && lng <= lngMax;

    const offersInBounds = allOffers.filter(offer => {
      if (offer?.marker && typeof offer.marker.getPosition === 'function') {
        const position = offer.marker.getPosition();
        if (position && typeof position.lat === 'function' && typeof position.lng === 'function') {
          const lat = position.lat();
          const lng = position.lng();
          if (withinBounds(lat, lng)) {
            return true;
          }
        }
      }
      const plot = offer?.plot;
      const lat = Number(plot?.lat);
      const lng = Number(plot?.lng);
      return withinBounds(lat, lng);
    });

    currentVoronoiOffers = offersInBounds.slice();
    voronoiHiddenOffersInBounds = offersInBounds.filter(offer => !filteredKeys.has(offer?.key));

    const supplementaryInBounds = voronoiSupplementaryOffers.filter(offer => {
      const position = getMarkerPositionForOffer(offer);
      if (!position) return false;
      return withinBounds(Number(position.lat), Number(position.lng));
    });

    currentVoronoiSupplementary = supplementaryInBounds.slice();
    voronoiSupplementaryOffersInBounds = supplementaryInBounds.slice();

    const visibleOffers = base.filter(o => {
      if (!o?.marker || typeof o.marker.getPosition !== 'function') {
        return false;
      }
      const position = o.marker.getPosition();
      return position ? bounds.contains(position) : false;
    });
    updateTagCollectionsForVisibleOffers(visibleOffers);

    const listContainer = document.getElementById("offersList");
    if (!listContainer) return;

    const sortedOffers = sortOffers(visibleOffers);

    listContainer.innerHTML = "";
    if (!sortedOffers.length) {
      listContainer.innerHTML = '<p class="no-offers">Brak ofert w widocznym obszarze</p>';
      if (voronoiLayerState.enabled) {
        const freezeActive = shouldFreezeVoronoiLayout();
        const selectionLock = getActiveVoronoiSelectionLock();
        const lockActive = !!selectionLock;
        const layoutFrozen = freezeActive || lockActive;
        const hasFrozenCache = layoutFrozen && Array.isArray(voronoiLayerState.cachedDataset?.dataset)
          && voronoiLayerState.cachedDataset.dataset.length;
        const hasFrozenLayout = (freezeActive && Array.isArray(voronoiLayerState.frozenLayout?.offers)
          && voronoiLayerState.frozenLayout.offers.length > 0)
          || (lockActive && Array.isArray(selectionLock?.layout?.offers)
            && selectionLock.layout.offers.length > 0);

        if (hasFrozenCache || hasFrozenLayout) {
          updateVoronoiLayer(true);
        } else if (!layoutFrozen) {
          clearVoronoiLayer();
          voronoiLayerState.cachedDataset = null;
          voronoiLayerState.cacheSignature = null;
          voronoiLayerState.frozenLayout = null;
          voronoiLayerState.selectionLock = null;
          voronoiLayerState.lastNonFrozenSource = {
            offers: [],
            signature: null,
            extent: null
          };
        }
      }
      refreshVoronoiIndicators();
      return;
    }

    sortedOffers.forEach(o => {
      const card = document.createElement("div");
      card.className = "offer-card offer-card--reverse";
      const price = Number(o.plot.price || 0);
      const area  = Number(o.plot.pow_dzialki_m2_uldk || 0);
      const ppm2  = price && area ? (price/area).toFixed(2) : "0.00";
      const detailsUrl = `details.html?id=${o.id}&plot=${o.index}`;
      const tagList = Array.isArray(o.tags) ? o.tags : [];
      const tagsMarkup = tagList.length
        ? `<div class="offer-tags">${tagList.map(tag => formatTagLabel(tag)).join(' ')}</div>`
        : '';
      const previewUrl = getPlotPreviewImage(o.plot || {}, o.data || {}, o.index, o.id);
      const previewMarkup = previewUrl
        ? `<div class="offer-card__media"><img src="${previewUrl}" alt="Podgląd działki" loading="lazy"></div>`
        : `<div class="offer-card__media offer-card__media--empty">Brak podglądu</div>`;

      card.innerHTML = `
        ${previewMarkup}
        <div class="offer-card__body">
          <h5>${o.plot.Id || "Brak identyfikatora"}</h5>
          ${o.data.city ? `<p><b>Miejscowość:</b> ${o.data.city}</p>` : ""}
          ${o.data.firstName ? `<p><b>Imię:</b> ${o.data.firstName}</p>` : ""}
          <p><b>Telefon:</b> ${formatPhone(o.data.phone) || "-"}</p>
          ${price ? `<p><b>Cena całkowita:</b> ${price.toLocaleString('pl-PL')} zł <span style="color:#5b6475;font-size:.85em;margin-left:5px;">${ppm2} zł/m²</span></p>` : ""}
          ${area  ? `<p><b>Powierzchnia:</b> ${area.toLocaleString('pl-PL')} m²</p>` : ""}
          ${tagsMarkup}
          <div class="offer-actions center">
            <a
              class="btn btn-accent btn-sm"
              href="${detailsUrl}"
              data-preserve-map-state="true"
              ${o.id ? `data-offer-id="${o.id}"` : ''}
              ${Number.isInteger(o.index) ? `data-plot-index="${o.index}"` : ''}
            >
              <i class="fas fa-info-circle"></i> Szczegóły
            </a>
          </div>
        </div>
      `;

      card.addEventListener("click", (e) => {
        if (e.target.closest('a')) return;
        panMapTo(o.marker.getPosition());
        openInfo(o.marker, infoHTML(o.plot, o.data, o.id, o.index), {
          offerId: typeof o.id === 'string' ? o.id : null,
          plotIndex: Number.isInteger(o.index) ? o.index : null
        });
      });

      listContainer.appendChild(card);
    });

    if (voronoiLayerState.enabled) {
      updateVoronoiLayer(true);
    }

    refreshVoronoiIndicators();
  }

  // EPSG:2180 -> WGS84
  function parseGeometry(geometryString) {
    const coords = [];
    try {
      proj4.defs("EPSG:2180", "+proj=tmerc +lat_0=0 +lon_0=19 +k=0.9993 +x_0=500000 +y_0=-5300000 +ellps=GRS80 +units=m +no_defs");
      const coordString = geometryString.match(/\(\(([^)]+)\)\)/)[1];
      const points = coordString.split(',');
      points.forEach(point => {
        const [xStr, yStr] = point.trim().split(' ');
        const x = parseFloat(xStr), y = parseFloat(yStr);
        const [lng, lat] = proj4("EPSG:2180", "WGS84", [x, y]);
        coords.push({ lat, lng });
      });
    } catch (e) { console.error("Błąd parsowania geometrii:", e, geometryString); }
    return coords;
  }

  // PUBLIC: focus z „Moje Oferty”
  window.focusOfferOnMap = function(offerId, plotIndex) {
    const match = allOffers.find(o => o.id === offerId && o.index === plotIndex);
    if (!match || !map) return;
    panMapTo(match.marker.getPosition(), 17);
    openInfo(match.marker, infoHTML(match.plot, match.data, match.id, match.index), {
      offerId: typeof match.id === 'string' ? match.id : null,
      plotIndex: Number.isInteger(match.index) ? match.index : null
    });
    document.querySelector('.map-container')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  };

  // ładowanie Google Maps
  const DEFAULT_GOOGLE_MAPS_API_KEY = 'AIzaSyCr5TmFxnT3enxmyr6vujF8leP995giw8I';
  const GOOGLE_MAPS_DEFAULT_HOSTS = ['grunteo.pl', 'www.grunteo.pl', 'trainingtwenty5.github.io'];

  function isDefaultMapsHost(hostname) {
    if (!hostname) return false;
    return GOOGLE_MAPS_DEFAULT_HOSTS.some(allowed => {
      if (hostname === allowed) return true;
      return hostname.endsWith(`.${allowed}`);
    });
  }

  function ensureMapsKeyPrompt() {
    let prompt = document.getElementById('mapsKeyPrompt');
    if (prompt) {
      return prompt;
    }
    const container = document.querySelector('.map-container');
    if (!container) return null;

    prompt = document.createElement('div');
    prompt.className = 'maps-key-prompt';
    prompt.id = 'mapsKeyPrompt';
    prompt.setAttribute('role', 'alertdialog');
    prompt.setAttribute('aria-modal', 'true');

    prompt.innerHTML = `
      <div class="maps-key-prompt__card">
        <h4 class="maps-key-prompt__title">Potrzebny klucz Google Maps</h4>
        <p class="maps-key-prompt__message" data-role="maps-key-message">
          Nie udało się wczytać mapy Google. Wprowadź własny klucz API, aby kontynuować.
        </p>
        <form class="maps-key-prompt__form" data-role="maps-key-form">
          <input
            type="text"
            class="maps-key-prompt__input"
            data-role="maps-key-input"
            placeholder="Wklej klucz API Google Maps"
            autocomplete="off"
            spellcheck="false"
            required
          />
          <div class="maps-key-prompt__actions">
            <button type="button" class="maps-key-prompt__dismiss" data-action="dismiss">Zamknij</button>
            <button type="submit" class="maps-key-prompt__submit">Zapisz klucz</button>
          </div>
          <p class="maps-key-prompt__hint">Klucz zostanie zapisany tylko w tej przeglądarce.</p>
        </form>
      </div>
    `;

    container.appendChild(prompt);

    const form = prompt.querySelector('[data-role="maps-key-form"]');
    const input = prompt.querySelector('[data-role="maps-key-input"]');
    const dismiss = prompt.querySelector('[data-action="dismiss"]');

    if (form) {
      form.addEventListener('submit', event => {
        event.preventDefault();
        if (!input) return;
        const value = input.value.trim();
        if (!value) {
          input.focus();
          return;
        }
        localStorage.setItem('googleMapsApiKey', value);
        hideMapsKeyPrompt();
        if (typeof showToast === 'function') {
          showToast('Zapisano klucz Google Maps. Odświeżam mapę…', 'success');
        }
        setTimeout(() => {
          window.location.reload();
        }, 300);
      });
    }

    if (dismiss) {
      dismiss.addEventListener('click', () => hideMapsKeyPrompt());
    }

    return prompt;
  }

  function showMapsKeyPrompt(message) {
    const prompt = ensureMapsKeyPrompt();
    if (!prompt) return;
    const messageNode = prompt.querySelector('[data-role="maps-key-message"]');
    const input = prompt.querySelector('[data-role="maps-key-input"]');
    if (messageNode && typeof message === 'string' && message.trim()) {
      messageNode.textContent = message.trim();
    }
    prompt.classList.add('maps-key-prompt--visible');
    if (input) {
      setTimeout(() => input.focus(), 120);
    }
  }

  function hideMapsKeyPrompt() {
    const prompt = document.getElementById('mapsKeyPrompt');
    if (!prompt) return;
    prompt.classList.remove('maps-key-prompt--visible');
  }

  function registerGoogleAuthFailureHandler() {
    window.gm_authFailure = () => {
      localStorage.removeItem('googleMapsApiKey');
      showMapsKeyPrompt('Google Maps odrzuciło klucz API. Wprowadź nowy klucz, aby zobaczyć mapę.');
    };
  }

  function loadGoogleMaps() {
    if (document.getElementById('googleMapsApiScript')) {
      return;
    }

    registerGoogleAuthFailureHandler();

    const storedKey = localStorage.getItem('googleMapsApiKey');
    const canUseDefault = isDefaultMapsHost(location.hostname);
    const apiKey = storedKey || (canUseDefault ? DEFAULT_GOOGLE_MAPS_API_KEY : '');

    if (!apiKey) {
      showMapsKeyPrompt('Aby zobaczyć mapę Google, wprowadź swój klucz API.');
      return;
    }

    const script = document.createElement('script');
    script.id = 'googleMapsApiScript';
    const params = new URLSearchParams({
      key: apiKey,
      callback: 'initMap'
    });
    script.src = `https://maps.googleapis.com/maps/api/js?${params.toString()}`;
    script.async = true;
    script.defer = true;
    script.addEventListener('error', () => {
      localStorage.removeItem('googleMapsApiKey');
      showMapsKeyPrompt('Nie udało się wczytać Map Google. Sprawdź klucz API i spróbuj ponownie.');
    });
    document.head.appendChild(script);
  }
  document.addEventListener('DOMContentLoaded', loadGoogleMaps);
</script>




<script type="module">
  import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, signOut,
    signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, sendEmailVerification,
    GoogleAuthProvider, signInWithPopup, signInWithRedirect,
    setPersistence,
    indexedDBLocalPersistence,
    browserLocalPersistence,
    browserSessionPersistence,
    inMemoryPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import {
    getFirestore, doc, setDoc, getDoc, updateDoc,
    collection, query, where, getDocs
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // --- KONFIG ---
  const firebaseConfig = {
    apiKey: "AIzaSyBdhMIiqetOfDGP85ERxtgwn3AXR50pBcE",
    authDomain: "base-468e0.firebaseapp.com",
    projectId: "base-468e0",
    storageBucket: "base-468e0.firebasestorage.app",
    messagingSenderId: "829161895559",
    appId: "1:829161895559:web:d832541aac05b35847ea22"
  };

  // --- INIT ---
  const app  = getApps().length ? getApp() : initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);
  auth.languageCode = 'pl';

  const persistenceChain = [
    ['indexedDB', indexedDBLocalPersistence],
    ['localStorage', browserLocalPersistence],
    ['session', browserSessionPersistence],
    ['memory', inMemoryPersistence]
  ];

  let configured = false;
  let lastError = null;
  for (const [label, persistence] of persistenceChain) {
    try {
      await setPersistence(auth, persistence);
      configured = true;
      break;
    } catch (error) {
      lastError = error;
      console.warn(`⚠️ Nie udało się ustawić persystencji Firebase (${label}).`, error);
    }
  }

  if (!configured && lastError) {
    console.error('❌ Wszystkie tryby persystencji Firebase nie powiodły się. Sesja może być niestabilna.', lastError);
  }

  const REGISTER_PROMPT_KEY = 'grunteo.registerPrompt';

  (function domainHint(){
    const hint = document.getElementById('domainWarning');
    if (!hint) return;
    const knownGood = ['localhost','127.0.0.1','trainingtwenty5.github.io','grunteo.pl','grunte.pl'];
    if (!knownGood.includes(location.hostname)) {
      hint.style.display = 'block';
    }
  })();

  const googleProvider = new GoogleAuthProvider();
  googleProvider.setCustomParameters({ prompt: 'select_account' });

  // --- DOM ---
  const authButtons   = document.getElementById('authButtons');
  const userMenu      = document.getElementById('userMenu');
  const loginBtn      = document.getElementById('loginBtn');
  const registerBtn   = document.getElementById('registerBtn');
  const accountBtn    = document.getElementById('accountBtn');
  const logoutBtn     = document.getElementById('logoutBtn');

  const loginModal    = document.getElementById('loginModal');
  const registerModal = document.getElementById('registerModal');
  const closeBtns     = document.querySelectorAll('.modal-close');
  const switchToRegister = document.getElementById('switchToRegister');
  const switchToLogin    = document.getElementById('switchToLogin');
  const loginForm     = document.getElementById('loginForm');
  const registerForm  = document.getElementById('registerForm');

  const userDashboard = document.getElementById('userDashboard');
  const userOffers    = document.getElementById('userOffers');

  const googleBtnRegister = document.getElementById('googleLoginBtn');
  const googleBtnLogin    = document.getElementById('googleLoginBtnLogin');

  let pendingRegisterPrompt = null;
  let rawRegisterPrompt = null;
  try {
    rawRegisterPrompt = sessionStorage.getItem(REGISTER_PROMPT_KEY);
    if (rawRegisterPrompt) {
      sessionStorage.removeItem(REGISTER_PROMPT_KEY);
    }
  } catch (_) {
    rawRegisterPrompt = null;
  }

  if (rawRegisterPrompt) {
    try {
      const parsed = JSON.parse(rawRegisterPrompt);
      if (parsed && typeof parsed === 'object') {
        pendingRegisterPrompt = parsed;
      } else {
        pendingRegisterPrompt = { openRegister: true };
      }
    } catch (_) {
      pendingRegisterPrompt = { openRegister: true };
    }
  }

  // --- POMOCNICZE UI ---
  const openModal  = (m) => m && (m.style.display = 'flex');
  const closeModal = (m) => m && (m.style.display = 'none');

  const triggerRegisterPrompt = () => {
    if (!pendingRegisterPrompt || !pendingRegisterPrompt.openRegister) return;
    if (registerModal) openModal(registerModal);
    const message = pendingRegisterPrompt.message || 'Po zalogowaniu się będziesz mógł edytować swoje ogłoszenie.';
    if (typeof window !== 'undefined' && typeof window.showToast === 'function') {
      window.showToast(message, pendingRegisterPrompt.type || 'info');
    } else {
      alert(message);
    }
    pendingRegisterPrompt = null;
  };

  function renderMobileAuth(user) {
    const navMenu = document.querySelector('.nav-menu');
    const mobileAuthC = document.getElementById('mobileAuth');
    if (!mobileAuthC) return;

    if (user) {
      const label = user.displayName ? user.displayName.split(' ')[0] : (user.email || 'Użytkownik');
      mobileAuthC.innerHTML = `
        <div class="nav-link" style="font-weight:600;">
          <i class="fas fa-user"></i> ${label}
        </div>
        <a href="index.html#userDashboard" class="nav-link" id="mobileAccountLink">Moje konto</a>
        <button class="btn btn-secondary" id="mobileLogoutBtn" style="width:100%;">
          <i class="fas fa-sign-out-alt"></i> Wyloguj się
        </button>
      `;
    } else {
      mobileAuthC.innerHTML = `
        <a href="#" id="loginLink" class="nav-link">Zaloguj się</a>
        <a href="#" id="registerLink" class="nav-link">Zarejestruj się</a>
      `;
    }

    const loginLink = document.getElementById('loginLink');
    const registerLink = document.getElementById('registerLink');
    const mobileLogoutBtn = document.getElementById('mobileLogoutBtn');
    const mobileAccountLink = document.getElementById('mobileAccountLink');

    loginLink && loginLink.addEventListener('click', (e) => {
      e.preventDefault();
      openModal(loginModal);
      navMenu?.classList.remove('active');
      mobileAuthC.style.display = 'none';
    });

    registerLink && registerLink.addEventListener('click', (e) => {
      e.preventDefault();
      openModal(registerModal);
      navMenu?.classList.remove('active');
      mobileAuthC.style.display = 'none';
    });

    mobileLogoutBtn && mobileLogoutBtn.addEventListener('click', async () => {
      try { await signOut(auth); } catch(e){ console.error(e); }
      navMenu?.classList.remove('active');
      mobileAuthC.style.display = 'none';
    });

    mobileAccountLink && mobileAccountLink.addEventListener('click', (e) => {
      e.preventDefault();
      navMenu?.classList.remove('active');
      mobileAuthC.style.display = 'none';
      window.location.href = 'index.html#userDashboard';
    });

    mobileAuthC.style.display = navMenu?.classList.contains('active') ? 'flex' : 'none';
  }

  // --- HANDLERY MODALI (desktop) ---
  loginBtn    && loginBtn.addEventListener('click', () => openModal(loginModal));
  registerBtn && registerBtn.addEventListener('click', () => openModal(registerModal));

  // Przełączanie między modalami
  switchToRegister && switchToRegister.addEventListener('click', (e) => {
    e.preventDefault(); closeModal(loginModal);  openModal(registerModal);
  });
  switchToLogin && switchToLogin.addEventListener('click', (e) => {
    e.preventDefault(); closeModal(registerModal); openModal(loginModal);
  });

  // Zamknięcie X i klik w tło
  closeBtns.forEach(b => b.addEventListener('click', () => closeModal(b.closest('.modal'))));
  window.addEventListener('click', (e) => {
    if (e.target.classList?.contains('modal')) closeModal(e.target);
  });

  accountBtn && accountBtn.addEventListener('click', (event) => {
    event.preventDefault?.();
    window.location.href = 'index.html#userDashboard';
  });

  // --- ŁADNE BŁĘDY ---
  const niceAuthError = (err) => {
    const code = err?.code || '';
    switch (code) {
      case 'auth/invalid-email':
        return 'Nieprawidłowy adres e-mail.';
      case 'auth/missing-password':
        return 'Podaj hasło.';
      case 'auth/invalid-credential':
        return 'Nieprawidłowy e-mail lub hasło.';
      case 'auth/user-not-found':
        return 'Użytkownik nie istnieje.';
      case 'auth/wrong-password':
        return 'Błędne hasło.';
      case 'auth/too-many-requests':
        return 'Za dużo prób. Spróbuj ponownie później.';
      case 'auth/unauthorized-domain':
        return `Domena ${location.hostname} nie jest autoryzowana w Firebase (Authentication → Authorized domains).`;
      case 'auth/network-request-failed':
        return 'Błąd sieci. Sprawdź połączenie z internetem.';
      case 'auth/popup-closed-by-user':
        return 'Zamykanie okna logowania przerwało proces.';
      case 'auth/cancelled-popup-request':
        return 'Logowanie zostało przerwane przez inne żądanie. Spróbuj ponownie.';
      case 'auth/popup-blocked':
        return 'Przeglądarka zablokowała okno logowania Google. Użyj przekierowania.';
      case 'auth/operation-not-supported-in-this-environment':
        return 'To środowisko nie wspiera tego typu logowania (np. file://). Uruchom stronę przez https.';
      default:
        return `Błąd: ${code || err?.message || 'nieznany'}`;
    }
  };

  // --- Email/hasło ---
  loginForm && loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('loginEmail').value.trim();
    const pass  = document.getElementById('loginPassword').value;
    try {
      await signInWithEmailAndPassword(auth, email, pass);
    } catch (err) {
      console.error('[login]', err);
      showToast(niceAuthError(err), 'error');
    }
  });

  registerForm && registerForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const name  = document.getElementById('registerName').value.trim();
    const email = document.getElementById('registerEmail').value.trim();
    const pass1 = document.getElementById('registerPassword').value;
    const pass2 = document.getElementById('registerConfirmPassword').value;
    if (pass1 !== pass2) {
      showToast('Hasła nie są identyczne!', 'error');
      return;
    }
    try {
      const { user } = await createUserWithEmailAndPassword(auth, email, pass1);
      if (name) await updateProfile(user, { displayName: name });
      await setDoc(doc(db, 'users', user.uid), {
        name: name || null,
        email,
        createdAt: new Date(),
        provider: "password"
      }, { merge: true });
      try {
        await sendEmailVerification(user);
        if (typeof window !== 'undefined') {
          if (typeof window.showToast === 'function') {
            window.showToast('Na Twój adres wysłaliśmy wiadomość z linkiem aktywacyjnym. Sprawdź skrzynkę i potwierdź konto.', 'info');
          } else {
            alert('Na Twój adres wysłaliśmy wiadomość z linkiem aktywacyjnym. Sprawdź skrzynkę i potwierdź konto.');
          }
        }
      } catch (verificationError) {
        console.error('[register][verification]', verificationError);
      }
    } catch (err) {
      console.error('[register]', err);
      showToast(niceAuthError(err), 'error');
    }
  });

  // --- Google ---
  async function signInWithGoogleSmart() {
    const isHttps = location.protocol === 'https:';
    if (!isHttps) {
      showToast('Uruchom stronę przez https (nie file://).', 'error');
      return;
    }
    try {
      await signInWithPopup(auth, googleProvider);
      closeModal(loginModal); closeModal(registerModal);
      document.querySelector('.nav-menu')?.classList.remove('active');
      document.getElementById('mobileAuth')?.setAttribute('style', 'display:none;');
    } catch (err) {
      console.error('[google]', err);
      if (err?.code === 'auth/popup-blocked' || err?.code === 'auth/operation-not-supported-in-this-environment') {
        await signInWithRedirect(auth, googleProvider);
      } else {
        showToast(niceAuthError(err), 'error');
      }
    }
  }
  [googleBtnRegister, googleBtnLogin].forEach(btn =>
    btn && btn.addEventListener('click', (e) => { e.preventDefault(); signInWithGoogleSmart(); })
  );

  // --- STAN LOGOWANIA ---
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      authButtons && (authButtons.style.display = 'none');
      userMenu    && (userMenu.style.display   = 'flex');
      userDashboard && (userDashboard.style.display = 'block');
      if (accountBtn) {
        const label = user.displayName || user.email || 'Moje konto';
        accountBtn.innerHTML = `<i class="fas fa-user"></i> ${label}`;
      }

      try { await loadUserOffers(user.email || null, user.uid || null); } catch(e){ console.error(e); }
      closeModal(loginModal); closeModal(registerModal);
      pendingRegisterPrompt = null;
    } else {
      authButtons && (authButtons.style.display = 'flex');
      userMenu    && (userMenu.style.display   = 'none');
      userDashboard && (userDashboard.style.display = 'none');
      userOffers && (userOffers.innerHTML = '');
      triggerRegisterPrompt();
    }
    renderMobileAuth(user);
  });

  // --- WYLOGOWANIE ---
  logoutBtn && logoutBtn.addEventListener('click', async () => {
    try { await signOut(auth); } catch(_) {}
  });
  
  
  
  
  
  
  
  

  // --- „Miękkie usuwanie” i ładowanie ofert (jeśli używasz) ---
async function loadUserOffers(email, uid) {
  try {
    const emailFields = ['email', 'userEmail', 'ownerEmail', 'createdByEmail', 'contactEmail'];
    const idFields    = ['userUid', 'uid', 'userId', 'ownerId', 'createdBy'];

    userOffers.innerHTML = '<p>Ładuję Twoje oferty…</p>';

    // Zbierz WSZYSTKIE pasujące dokumenty z wielu zapytań i zdeduplikuj po id
    const results = new Map(); // id -> QueryDocumentSnapshot

    // — po e-mailu (uwzględnij różne wielkości liter)
    if (email) {
      const variants = [...new Set([email, email.toLowerCase()])];
      for (const field of emailFields) {
        for (const val of variants) {
          try {
            const s = await getDocs(query(collection(db, 'propertyListings'), where(field, '==', val)));
            s.forEach(d => results.set(d.id, d));
          } catch (e) {
            console.warn('Email query failed for', field, e);
          }
        }
      }
    }

    // — po UID
    if (uid) {
      for (const field of idFields) {
        try {
          const s = await getDocs(query(collection(db, 'propertyListings'), where(field, '==', uid)));
          s.forEach(d => results.set(d.id, d));
        } catch (e) {
          console.warn('UID query failed for', field, e);
        }
      }
    }

    userOffers.innerHTML = '';

    if (results.size === 0) {
      userOffers.innerHTML = '<p>Nie masz jeszcze żadnych aktywnych ofert.</p>';
      return;
    }

    // Render (twój fragment bez zmian poza źródłem danych)
    Array.from(results.values()).forEach((docu) => {
      const offer  = docu.data();
      const offerId = docu.id;
      const activePlots = getActivePlotEntries(offer.plots);
      if (!activePlots.length) return;

      activePlots.forEach(({ plot, originalIndex }, i) => {
        const price = Number(plot.price || 0);
        const area  = Number(plot.pow_dzialki_m2_uldk || plot.area || plot.areaM2 || 0);
        const ppm2  = price && area ? Math.round(price/area) : 0;
        const detailsUrl = `details.html?id=${offerId}&plot=${originalIndex}`;
        const locationSources = [plot.location, plot.city, offer.city];
        if (typeof offer.location === 'string') {
          locationSources.push(offer.location);
        } else if (offer.location && typeof offer.location === 'object') {
          locationSources.push(offer.location.city, offer.location.town, offer.location.municipality);
        }
        const locationLabel = pickDisplayValue(locationSources, 'Nie podano');

        const previewUrl = getPlotPreviewImage(plot || {}, offer || {}, originalIndex, offerId);
        const previewMarkup = previewUrl
          ? `<div class="offer-card__media"><img src="${previewUrl}" alt="Podgląd działki" loading="lazy"></div>`
          : `<div class="offer-card__media offer-card__media--empty">Brak podglądu</div>`;

        const el = document.createElement('div');
        el.className = 'offer-card';
        el.innerHTML = `
          ${previewMarkup}
          <div class="offer-card__body">
            <h3 class="offer-title">${plot.Id || `Działka ${i+1}`}</h3>
            <div class="offer-details">
              <p><strong>Lokalizacja:</strong> ${locationLabel}</p>
              ${area  ? `<p><strong>Powierzchnia:</strong> ${area.toLocaleString('pl-PL')} m²</p>` : ''}
              ${price ? `<p><strong>Cena całkowita:</strong> ${price.toLocaleString('pl-PL')} zł
                ${ppm2 ? `<span style="color:#888;font-size:.85em;margin-left:5px;">${ppm2.toLocaleString('pl-PL')} zł/m²</span>`:''}
              </p>` : ''}
            </div>
            <div class="offer-actions">
              <a
                class="btn btn-accent btn-sm"
                href="${detailsUrl}"
                data-preserve-map-state="true"
                ${offerId ? `data-offer-id="${offerId}"` : ''}
                ${Number.isInteger(originalIndex) ? `data-plot-index="${originalIndex}"` : ''}
              >
                <i class="fas fa-info-circle"></i> Szczegóły
              </a>
              <button class="btn btn-primary btn-sm" onclick="window.location.href='edit.html?id=${offerId}&plot=${originalIndex}'">
                <i class="fas fa-edit"></i> Edytuj
              </button>
              <button class="btn btn-secondary btn-sm" onclick="deletePlot && deletePlot('${offerId}', ${originalIndex}, '${(plot.Id||`Działka ${i+1}`).replace(/'/g,"\\'")}')">
                <i class="fas fa-trash"></i> Usuń
              </button>
            </div>
          </div>
        `;
        el.addEventListener('click', (e) => {
          if (e.target.closest('.offer-actions')) return;
          window.focusOfferOnMap?.(offerId, originalIndex);
        });
        userOffers.appendChild(el);
      });
    });

    if (!userOffers.querySelector('.offer-card')) {
      userOffers.innerHTML = '<p>Nie masz jeszcze żadnych aktywnych ofert.</p>';
    }
  } catch (error) {
    console.error('Error loading offers: ', error);
    userOffers.innerHTML = '<p>Wystąpił błąd podczas ładowania ofert.</p>';
  }
}

async function deletePlot(offerId, plotIndex, title) {
  if (!(await showConfirmModal(`Czy na pewno chcesz usunąć działkę "${title}"?`))) return;
  try {
    const offerRef = doc(db, 'propertyListings', offerId);
    const snap = await getDoc(offerRef);
    if (!snap.exists()) {
      showToast('Ogłoszenie nie istnieje.', 'error');
      return;
    }
    const data = snap.data();
    if (!Array.isArray(data.plots)) {
      showToast('Brak działek do usunięcia.', 'error');
      return;
    }
    const plots = Array.isArray(data.plots) ? [...data.plots] : [];
    const plot = plots[plotIndex];
    if (!plot) {
      showToast('Nie znaleziono wskazanej działki.', 'error');
      return;
    }
    plots[plotIndex] = { ...plot, mock: false };
    await setDoc(offerRef, { plots }, { merge: true });

    if (typeof window.bumpOffersRevisionHint === 'function') {
      window.bumpOffersRevisionHint();
    } else {
      clearOffersCache();
    }

    showToast('Działka usunięta', 'success');
    if (auth.currentUser) {
      loadUserOffers(auth.currentUser.email || null, auth.currentUser.uid || null);
    }
    if (typeof window.loadOffers === 'function') {
      await window.loadOffers({ forceRefresh: true });
    }
  } catch (err) {
    console.error('deletePlot', err);
    showToast('Nie udało się usunąć działki.', 'error');
  }
}

window.deletePlot = deletePlot;



  // --- EXPORTY DLA ZWYKŁYCH SKRYPTÓW (jeśli używasz poza module) ---
  window.db = db;
  window.collection = collection;
  window.getDocs = getDocs;
  window.query = query;
  window.where = where;
  window.doc       = doc;
  window.updateDoc = updateDoc;
</script>


<script>
  document.addEventListener('DOMContentLoaded', function() {
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const navMenu = document.querySelector('.nav-menu');
    const mobileAuth = document.getElementById('mobileAuth');

    mobileMenuBtn?.addEventListener('click', function () {
      navMenu.classList.toggle('active');
      if (mobileAuth) {
        mobileAuth.style.display = navMenu.classList.contains('active') ? 'flex' : 'none';
      }
    });

    window.addEventListener('resize', () => {
      if (window.innerWidth > 768) {
        navMenu.classList.remove('active');
        if (mobileAuth) mobileAuth.style.display = 'none';
      }
    });
  });
</script>

  <div class="cookie-banner" data-cookie-banner role="dialog" aria-modal="false" aria-live="polite" tabindex="-1">
    <div class="cookie-banner__icon" aria-hidden="true">
      <i class="fas fa-cookie-bite"></i>
    </div>
    <div class="cookie-banner__content">
      <h3 class="cookie-banner__title">Szanujemy Twoją prywatność</h3>
      <p class="cookie-banner__text">
        Korzystamy z plików cookies, aby zapewnić prawidłowe działanie serwisu, analizować ruch i rozwijać nasze usługi.
        Szczegółowe informacje znajdziesz w <a href="RODO.html">Informacji RODO</a> oraz w
        <a href="polityka-prywatnosci.html">Polityce prywatności i cookies</a>.
      </p>
      <div class="cookie-banner__actions">
        <button type="button" class="btn btn-primary cookie-banner__btn" data-cookie-accept>Akceptuję wszystkie</button>
        <button type="button" class="btn btn-secondary cookie-banner__btn" data-cookie-decline>Tylko niezbędne</button>
        <a class="cookie-banner__link" href="polityka-prywatnosci.html#cookies">
          <i class="fas fa-sliders" aria-hidden="true"></i>
          Zarządzaj ustawieniami
        </a>
      </div>
    </div>
  </div>
  <button class="cookie-preferences" type="button" data-cookie-preferences hidden aria-haspopup="dialog" aria-expanded="false">
    <i class="fas fa-cookie-bite" aria-hidden="true"></i>
    Ustawienia cookies
  </button>
  <script src="assets/cookies.js"></script>

</body>
</html>
